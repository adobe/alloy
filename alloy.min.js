/**
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

!(function () {
  "use strict";
  var e = (e) => null == e,
    t = (t) => !e(t) && !Array.isArray(t) && "object" == typeof t;
  /*! js-cookie v3.0.5 | MIT */
  function n(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) e[r] = n[r];
    }
    return e;
  }
  var r = (function e(t, r) {
      function o(e, o, i) {
        if ("undefined" != typeof document) {
          ("number" == typeof (i = n({}, r, i)).expires &&
            (i.expires = new Date(Date.now() + 864e5 * i.expires)),
            i.expires && (i.expires = i.expires.toUTCString()),
            (e = encodeURIComponent(e)
              .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
              .replace(/[()]/g, escape)));
          var a = "";
          for (var s in i)
            i[s] &&
              ((a += "; " + s), !0 !== i[s] && (a += "=" + i[s].split(";")[0]));
          return (document.cookie = e + "=" + t.write(o, e) + a);
        }
      }
      return Object.create(
        {
          set: o,
          get: function (e) {
            if ("undefined" != typeof document && (!arguments.length || e)) {
              for (
                var n = document.cookie ? document.cookie.split("; ") : [],
                  r = {},
                  o = 0;
                o < n.length;
                o++
              ) {
                var i = n[o].split("="),
                  a = i.slice(1).join("=");
                try {
                  var s = decodeURIComponent(i[0]);
                  if (((r[s] = t.read(a, s)), e === s)) break;
                } catch (e) {}
              }
              return e ? r[e] : r;
            }
          },
          remove: function (e, t) {
            o(e, "", n({}, t, { expires: -1 }));
          },
          withAttributes: function (t) {
            return e(this.converter, n({}, this.attributes, t));
          },
          withConverter: function (t) {
            return e(n({}, this.converter, t), this.attributes);
          },
        },
        {
          attributes: { value: Object.freeze(r) },
          converter: { value: Object.freeze(t) },
        },
      );
    })(
      {
        read: function (e) {
          return (
            '"' === e[0] && (e = e.slice(1, -1)),
            e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
          );
        },
        write: function (e) {
          return encodeURIComponent(e).replace(
            /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
            decodeURIComponent,
          );
        },
      },
      { path: "/" },
    ),
    o = {
      get: r.get.bind(r),
      set: r.set.bind(r),
      remove: r.remove.bind(r),
      withConverter: r.withConverter.bind(r),
    };
  const i = (e, n) => {
    Object.keys(n).forEach((r) => {
      t(e[r]) && t(n[r]) ? i(e[r], n[r]) : (e[r] = n[r]);
    });
  };
  var a = (t, ...n) => {
      if (e(t))
        throw new TypeError('deepAssign "target" cannot be null or undefined');
      const r = Object(t);
      return (n.forEach((e) => i(r, Object(e))), r);
    },
    s = (e, t) => (n) => {
      const r = t.split(".").reduce((e, t) => ((e[t] = e[t] || {}), e[t]), e);
      a(r, n);
    },
    c = () => {
      const e = [];
      return {
        add(t) {
          e.push(t);
        },
        call: (...t) => Promise.all(e.map((e) => e(...t))),
      };
    },
    d = ({ logger: e, cookieJar: t }) => ({
      ...t,
      set(n, r, o) {
        (e.info("Setting cookie", { name: n, value: r, ...o }), t.set(n, r, o));
      },
    }),
    l = () => {
      const e = {};
      return (
        (e.promise = new Promise((t, n) => {
          ((e.resolve = t), (e.reject = n));
        })),
        e
      );
    };
  const u = (e, t) => e === t;
  var p = (e, t) => e.appendChild(t);
  var g = (e, n = {}, r = {}, o = [], i = document) => {
    const a = i.createElement(e);
    return (
      Object.keys(n).forEach((e) => {
        a.setAttribute(e, n[e]);
      }),
      ((e, n) => {
        Object.keys(n).forEach((r) => {
          if ("style" === r && t(n[r])) {
            const t = n[r];
            Object.keys(t).forEach((n) => {
              e.style[n] = t[n];
            });
          } else e[r] = n[r];
        });
      })(a, r),
      o.forEach((e) => p(a, e)),
      a
    );
  };
  const m = "IMG",
    f = "STYLE",
    h = "SCRIPT";
  var y = ({ src: e, currentDocument: t = document }) =>
      new Promise((n, r) => {
        g(m, { src: e }, { onload: n, onerror: r, onabort: r }, [], t);
      }),
    v = (e) => "function" == typeof e,
    w = (e) => Array.isArray(e) && e.length > 0,
    I = (e) => (Array.isArray(e) ? e : null == e ? [] : [].slice.call(e));
  const b = /^\s*>/;
  var E = (e, t) =>
      b.test(t)
        ? I(e.querySelectorAll(":scope " + t))
        : I(e.querySelectorAll(t)),
    C = ":shadow";
  const k = (e, t) => {
    const n = t;
    if (!n.startsWith(">")) return n;
    return (
      (e instanceof Element || e instanceof Document ? ":scope" : ":host") +
      " " +
      n
    );
  };
  var S = (e, t) => {
      const n = ((e) => e.split(C))(t);
      if (n.length < 2) return E(e, t);
      let r = e;
      for (let e = 0; e < n.length; e += 1) {
        const t = n[e].trim();
        if ("" === t && r.shadowRoot) {
          r = r.shadowRoot;
          continue;
        }
        const o = k(r, t),
          i = E(r, o);
        if (0 === i.length || !i[0] || !i[0].shadowRoot) return i;
        r = i[0].shadowRoot;
      }
    },
    P = (e, t = document) => (-1 === e.indexOf(C) ? E(t, e) : S(t, e));
  const D = "MutationObserver",
    R = { childList: !0, subtree: !0 },
    T = (e) => new Error("Could not find: " + e),
    O = (e) => new Promise(e);
  var N = (e, t = P, n = 5e3, r = window, o = document) => {
    const i = t(e);
    return w(i)
      ? Promise.resolve(i)
      : ((e) => v(e[D]))(r)
        ? ((e, t, n, r, o) =>
            O((i, a) => {
              let s;
              const c = new e[D](() => {
                const e = o(n);
                w(e) && (c.disconnect(), s && clearTimeout(s), i(e));
              });
              ((s = setTimeout(() => {
                (c.disconnect(), a(T(n)));
              }, r)),
                c.observe(t, R));
            }))(r, o, e, n, t)
        : ((e) => "visible" === e.visibilityState)(o)
          ? ((e, t, n, r) =>
              O((o, i) => {
                const a = () => {
                  const n = r(t);
                  w(n) ? o(n) : e.requestAnimationFrame(a);
                };
                (a(),
                  setTimeout(() => {
                    i(T(t));
                  }, n));
              }))(r, e, n, t)
          : ((e, t, n) =>
              O((r, o) => {
                const i = () => {
                  const t = n(e);
                  w(t) ? r(t) : setTimeout(i, 100);
                };
                (i(),
                  setTimeout(() => {
                    o(T(e));
                  }, t));
              }))(e, n, t);
  };
  let M;
  const A = (e = document) => {
      if (void 0 === M) {
        const t = e.querySelector("[nonce]");
        M = t && (t.nonce || t.getAttribute("nonce"));
      }
      return M;
    },
    x = (e, t = {}) =>
      document.querySelector('script[src="' + e + '"]')
        ? (t.onLoad && t.onLoad(), Promise.resolve())
        : new Promise((n, r) => {
            const { attributes: o = {}, onLoad: i, onError: a } = t,
              s = g(
                "script",
                {
                  type: "text/javascript",
                  src: e,
                  async: !0,
                  ...(A() && { nonce: A() }),
                  ...o,
                },
                {
                  onload: () => {
                    (i && i(), n());
                  },
                  onerror: () => {
                    const t = new Error("Failed to load script: " + e);
                    (a && a(t), r(t));
                  },
                },
              ),
              c = () => {
                const e = document.head || document.body;
                if (e) p(e, s);
                else {
                  const e = new Error(
                    "Neither <head> nor <body> available for script insertion.",
                  );
                  (a && a(e), r(e));
                }
              };
            "loading" === document.readyState
              ? document.addEventListener("DOMContentLoaded", c)
              : c();
          });
  var q = (e) => {
    const t = e.parentNode;
    return t ? t.removeChild(e) : null;
  };
  const L = { name: "Adobe Alloy" },
    U = { style: { display: "none", width: 0, height: 0 } };
  var j = (e) => t(e) && 0 === Object.keys(e).length;
  const _ = (n, r) =>
      e(n) || !t(n)
        ? n
        : Object.keys(n).reduce((e, o) => {
            const i = n[o];
            if (t(i)) {
              const t = _(i, r);
              return j(t) ? e : { ...e, [o]: t };
            }
            return r(i) ? { ...e, [o]: i } : e;
          }, {}),
    F = (e) =>
      ((e) => {
        let t = 2166136261;
        const n = new TextEncoder().encode(e);
        for (let e = 0; e < n.length; e += 1)
          ((t ^= n[e]), (t = Math.imul(t, 16777619)));
        return t >>> 0;
      })(e)
        .toString(16)
        .padStart(8, "0");
  var B = "com.adobe.alloy.";
  const V = B + "getTld";
  var H = "kndctr",
    z = (e) => e.replace("@", "_"),
    J = (e, t) => H + "_" + z(e) + "_" + t,
    G = (e, t) => {
      const n = {};
      return (
        e.forEach((e) => {
          const r = t(e);
          (n[r] || (n[r] = []), n[r].push(e));
        }),
        n
      );
    };
  const Q = "Chrome",
    X = "Edge",
    W = "EdgeChromium",
    Y = "Firefox",
    K = "IE",
    $ = "Safari",
    Z = "Unknown";
  var ee = (e) => {
    let t,
      n = !1;
    return () => (n || ((n = !0), (t = e())), t);
  };
  const te = [Q, X, W, "IE", Z];
  var ne = ({ orgId: e }) => {
    const t = J(e, "identity");
    return () => Boolean(o.get(t));
  };
  const re = (e, t, n) => ({
    getItem(r) {
      try {
        return e[t].getItem(n + r);
      } catch {
        return null;
      }
    },
    setItem(r, o) {
      try {
        return (e[t].setItem(n + r, o), !0);
      } catch {
        return !1;
      }
    },
    clear() {
      try {
        return (
          Object.keys(e[t]).forEach((r) => {
            r.startsWith(n) && e[t].removeItem(r);
          }),
          !0
        );
      } catch {
        return !1;
      }
    },
  });
  var oe = (e) => (t) => {
      const n = B + t;
      return {
        session: re(e, "sessionStorage", n),
        persistent: re(e, "localStorage", n),
      };
    },
    ie = (e) => "boolean" == typeof e,
    ae = (e) => "number" == typeof e && !Number.isNaN(e),
    se = (e) => {
      const t = parseInt(e, 10);
      return ae(t) && e === t;
    },
    ce = (e) => "string" == typeof e,
    de = (e) => ce(e) && e.length > 0,
    le = () => {};
  const ue = (e) => {
      const t = {},
        n = e.split(".");
      switch (n.length) {
        case 1:
          ((t.subdomain = ""), (t.domain = e), (t.topLevelDomain = ""));
          break;
        case 2:
          ((t.subdomain = ""), (t.domain = e), (t.topLevelDomain = n[1]));
          break;
        case 3:
          ((t.subdomain = "www" === n[0] ? "" : n[0]),
            (t.domain = e),
            (t.topLevelDomain = n[2]));
          break;
        case 4:
          ((t.subdomain = "www" === n[0] ? "" : n[0]),
            (t.domain = e),
            (t.topLevelDomain = n[2] + "." + n[3]));
      }
      return t;
    },
    pe = (e, t = ue) => {
      ce(e) || (e = "");
      const n = ((e) => {
          try {
            const t = new URL(e);
            let n = t.pathname;
            return (
              e.endsWith("/") || "/" !== n || (n = ""),
              {
                host: t.hostname,
                path: n,
                query: t.search.replace(/^\?/, ""),
                anchor: t.hash.replace(/^#/, ""),
              }
            );
          } catch {
            return { host: "", path: "", query: "", anchor: "" };
          }
        })(e),
        { host: r, path: o, query: i, anchor: a } = n;
      return { path: o, query: i, fragment: a, ...t(r) };
    };
  var ge, me;
  function fe(e) {
    return e &&
      e.__esModule &&
      Object.prototype.hasOwnProperty.call(e, "default")
      ? e.default
      : e;
  }
  var he =
      (me ||
        ((me = 1),
        (ge = {
          parse: function (e) {
            return (function (e) {
              var t = {};
              if (!e || "string" != typeof e) return t;
              var n = e.trim().replace(/^[?#&]/, ""),
                r = new URLSearchParams(n),
                o = r.keys();
              do {
                var i = o.next(),
                  a = i.value;
                if (a) {
                  var s = r.getAll(a);
                  1 === s.length ? (t[a] = s[0]) : (t[a] = s);
                }
              } while (!1 === i.done);
              return t;
            })(e);
          },
          stringify: function (e) {
            return (function (e) {
              var t = "{{space}}",
                n = new URLSearchParams();
              return (
                Object.keys(e).forEach(function (r) {
                  var o = e[r];
                  ("string" == typeof e[r]
                    ? (o = o.replace(/ /g, t))
                    : ["object", "undefined"].includes(typeof o) &&
                      !Array.isArray(o) &&
                      (o = ""),
                    Array.isArray(o)
                      ? o.forEach(function (e) {
                          n.append(r, e);
                        })
                      : n.append(r, o));
                }),
                n
                  .toString()
                  .replace(new RegExp(encodeURIComponent(t), "g"), "%20")
              );
            })(e);
          },
        })),
      ge),
    ye = fe(he);
  const ve = (e) =>
    Array.isArray(e)
      ? e.map((e) => ve(e))
      : "object" == typeof e && null !== e
        ? Object.keys(e)
            .sort()
            .reduce((t, n) => ((t[n] = ve(e[n])), t), {})
        : e;
  var we = (e) => (e instanceof Error ? e : new Error(e)),
    Ie = ({ error: e, message: t }) => {
      try {
        e.message = t;
      } catch {}
    },
    be = ({ error: e, message: t }) => {
      const n = we(e),
        r = t + "\nCaused by: " + n.message;
      return (Ie({ error: n, message: r }), n);
    },
    Ee = (e, t) => {
      if (ae(e) || ce(e)) {
        const t = Math.round(Number(e));
        if (!Number.isNaN(t)) return t;
      }
      return t;
    };
  const Ce = (e, t, n) => ("" + e).padStart(t, n);
  const ke = [];
  for (let e = 0; e < 256; ++e) ke.push((e + 256).toString(16).slice(1));
  let Se;
  const Pe = new Uint8Array(16);
  var De = {
    randomUUID:
      "undefined" != typeof crypto &&
      crypto.randomUUID &&
      crypto.randomUUID.bind(crypto),
  };
  function Re(e, t, n) {
    if (De.randomUUID && !t && !e) return De.randomUUID();
    const r =
      (e = e || {}).random ??
      e.rng?.() ??
      (function () {
        if (!Se) {
          if ("undefined" == typeof crypto || !crypto.getRandomValues)
            throw new Error(
              "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported",
            );
          Se = crypto.getRandomValues.bind(crypto);
        }
        return Se(Pe);
      })();
    if (r.length < 16) throw new Error("Random bytes length must be >= 16");
    if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), t)) {
      if ((n = n || 0) < 0 || n + 16 > t.length)
        throw new RangeError(
          "UUID byte range " + n + ":" + (n + 15) + " is out of buffer bounds",
        );
      for (let e = 0; e < 16; ++e) t[n + e] = r[e];
      return t;
    }
    return (function (e, t = 0) {
      return (
        ke[e[t + 0]] +
        ke[e[t + 1]] +
        ke[e[t + 2]] +
        ke[e[t + 3]] +
        "-" +
        ke[e[t + 4]] +
        ke[e[t + 5]] +
        "-" +
        ke[e[t + 6]] +
        ke[e[t + 7]] +
        "-" +
        ke[e[t + 8]] +
        ke[e[t + 9]] +
        "-" +
        ke[e[t + 10]] +
        ke[e[t + 11]] +
        ke[e[t + 12]] +
        ke[e[t + 13]] +
        ke[e[t + 14]] +
        ke[e[t + 15]]
      ).toLowerCase();
    })(r);
  }
  const Te = (e) =>
      function (t, n) {
        return null == t ? t : e.call(this, t, n);
      },
    Oe = (e, t) =>
      function (n, r) {
        return t.call(this, e.call(this, n, r), r);
      },
    Ne = (e, t) =>
      function (n, r) {
        const o = [],
          i = [e, t].reduce((e, t) => {
            try {
              return t.call(this, e, r);
            } catch (t) {
              return (o.push(t), e);
            }
          }, n);
        if (o.length) throw new Error(o.join("\n"));
        return i;
      },
    Me = (e, t, n) => Object.assign(Oe(e, t), e, n),
    Ae = (e, t, n) => Object.assign(Oe(e, Te(t)), e, n),
    xe = (e, t, n, r) => {
      if (!e)
        throw new Error(
          "'" + n + "': Expected " + r + ", but got " + JSON.stringify(t) + ".",
        );
    };
  var qe = (e, t) => (xe(ie(e), e, t, "true or false"), e),
    Le = (e, t) => (xe(v(e), e, t, "a function"), e),
    Ue = (e, t) =>
      function (n, r) {
        let o;
        const i = e.find((e) => {
          try {
            return ((o = e.call(this, n, r)), !0);
          } catch {
            return !1;
          }
        });
        return (xe(i, n, r, t), o);
      },
    je = (e) =>
      function (t, n) {
        xe(Array.isArray(t), t, n, "an array");
        const r = [],
          o = t.map((o, i) => {
            try {
              return e.call(this, o, n + "[" + i + "]", t);
            } catch (e) {
              return void r.push(e.message);
            }
          });
        if (r.length) throw new Error(r.join("\n"));
        return o;
      },
    _e = (e = "This field has been deprecated") =>
      function (t, n) {
        let r = e;
        return (
          void 0 !== t &&
            (n && (r = "'" + n + "': " + r),
            this && this.logger && this.logger.warn(r)),
          t
        );
      },
    Fe = (e) =>
      function (n, r) {
        xe(t(n), n, r, "an object");
        const o = [],
          i = {};
        if (
          (Object.keys(n).forEach((t) => {
            const a = n[t],
              s = r ? r + "." + t : t;
            try {
              const n = e.call(this, a, s);
              void 0 !== n && (i[t] = n);
            } catch (e) {
              o.push(e.message);
            }
          }),
          o.length)
        )
          throw new Error(o.join("\n"));
        return i;
      },
    Be = (e, t) => (n, r) => (
      xe(n >= t, n, r, e + " greater than or equal to " + t),
      n
    ),
    Ve = (e) => (n, r) => (
      t(n) ? xe(!j(n), n, r, e) : xe(n.length > 0, n, r, e),
      n
    ),
    He = (e) =>
      function (n, r) {
        xe(t(n), n, r, "an object");
        const o = [],
          i = {};
        if (
          (Object.keys(e).forEach((t) => {
            const a = n[t],
              s = e[t],
              c = r ? r + "." + t : t;
            try {
              const e = s.call(this, a, c);
              void 0 !== e && (i[t] = e);
            } catch (e) {
              o.push(e.message);
            }
          }),
          Object.keys(n).forEach((e) => {
            Object.prototype.hasOwnProperty.call(i, e) || (i[e] = n[e]);
          }),
          o.length)
        )
          throw new Error(o.join("\n"));
        return i;
      },
    ze = (e, n, r) =>
      function (o, i) {
        xe(t(o), o, i, "an object");
        const { [e]: a, [r]: s, ...c } = o,
          d = n(a, i);
        if (void 0 !== d) {
          let t =
            "The field '" + e + "' is deprecated. Use '" + r + "' instead.";
          if ((i && (t = "'" + i + "': " + t), void 0 !== s && s !== d))
            throw new Error(t);
          this && this.logger && this.logger.warn(t);
        }
        return { [r]: s || d, ...c };
      },
    Je = () => (e, t) => (
      xe(
        ((e) => {
          const t = Object.create(null);
          for (let n = 0; n < e.length; n += 1) {
            const r = e[n];
            if (r in t) return !1;
            t[r] = !0;
          }
          return !0;
        })(e),
        e,
        t,
        "array values to be unique",
      ),
      e
    );
  const Ge = /^[a-z0-9.-]{1,}$/i;
  var Qe = (e, t) => (xe(Ge.test(e), e, t, "a valid domain"), e),
    Xe = (e, t) => (xe(se(e), e, t, "an integer"), e),
    We = (e, t) => (xe(ae(e), e, t, "a number"), e),
    Ye = (e, t) => (
      xe(
        ((e) => {
          try {
            return null !== RegExp(e);
          } catch {
            return !1;
          }
        })(e),
        e,
        t,
        "a regular expression",
      ),
      e
    ),
    Ke = (e, t) => {
      if (null == e) throw new Error("'" + t + "' is a required option");
      return e;
    },
    $e = (e, t) => (xe(ce(e), e, t, "a string"), e);
  const Ze = (e) => e;
  ((Ze.default = function (e) {
    return Me(this, ((e) => (t) => (null == t ? e : t))(e));
  }),
    (Ze.required = function () {
      return Me(this, Ke);
    }),
    (Ze.deprecated = function (e) {
      return Me(this, _e(e));
    }));
  const et = function () {
      return Ae(this, Qe);
    },
    tt = function (e) {
      return Ae(this, Be("an integer", e));
    },
    nt = function (e) {
      return Ae(this, Be("a number", e));
    },
    rt = function (e) {
      return Ae(
        this,
        ((t = "a number"),
        (n = e),
        (e, r) => (xe(e <= n, e, r, t + " less than or equal to " + n), e)),
      );
      var t, n;
    },
    ot = function () {
      return Ae(this, Xe, { minimum: tt });
    },
    it = function () {
      return Ae(this, Ve("a non-empty string"));
    },
    at = function () {
      return Ae(this, Ve("a non-empty array"));
    },
    st = function () {
      return Ae(this, Ve("a non-empty object"));
    },
    ct = function () {
      return Ae(this, Ye);
    },
    dt = function (e) {
      return Ae(
        this,
        ((e) => (t, n) => (
          xe(e.test(t), t, n, "does not match the " + e.toString()),
          t
        ))(e),
      );
    },
    lt = function () {
      return Ae(
        this,
        (() => {
          const e = [];
          return (t, n) => (
            xe(-1 === e.indexOf(t), t, n, "a unique value across instances"),
            e.push(t),
            t
          );
        })(),
      );
    },
    ut = function () {
      return Ae(this, Je());
    },
    pt = (e) => ({
      noUnknownFields: function () {
        return Ae(
          this,
          ((e) => (t, n) => {
            const r = [];
            if (
              (Object.keys(t).forEach((t) => {
                if (!e[t]) {
                  const e = n ? n + "." + t : t;
                  r.push("'" + e + "': Unknown field.");
                }
              }),
              r.length)
            )
              throw new Error(r.join("\n"));
            return t;
          })(e),
        );
      },
      nonEmpty: st,
      concat: function (t) {
        const n = { ...e, ...t.schema };
        return Ae(this, t, pt(n));
      },
      renamed: function (e, t, n) {
        return (
          (r = this),
          (o = ze(e, t, n)),
          Object.assign(Ne(Te(o), r), r, i)
        );
        var r, o, i;
      },
      schema: e,
    }),
    gt = function (e, t) {
      return Me(this, Ue(e, t));
    }.bind(Ze),
    mt = function () {
      return this;
    }.bind(Ze),
    ft = function (e) {
      return Ae(this, je(e), { nonEmpty: at, uniqueItems: ut });
    }.bind(Ze),
    ht = function () {
      return Ae(this, qe);
    }.bind(Ze),
    yt = function () {
      return Ae(this, Le);
    }.bind(Ze),
    vt = function (e) {
      return Ae(this, ((e) => (t, n) => (xe(t === e, t, n, "" + e), t))(e));
    }.bind(Ze),
    wt = function () {
      return Ae(this, We, {
        minimum: nt,
        maximum: rt,
        integer: ot,
        unique: lt,
      });
    }.bind(Ze),
    It = function (e) {
      return Ae(this, Fe(e), { nonEmpty: st });
    }.bind(Ze),
    bt = function (e) {
      return Ae(this, He(e), pt(e));
    }.bind(Ze),
    Et = function () {
      return Ae(this, $e, {
        regexp: ct,
        domain: et,
        nonEmpty: it,
        unique: lt,
        matches: dt,
      });
    }.bind(Ze),
    Ct = function (...e) {
      return gt(e.map(vt), "one of these values: " + JSON.stringify(e));
    };
  var kt = It(
      ft(
        bt({
          authenticatedState: Ct("ambiguous", "authenticated", "loggedOut"),
          id: Et(),
          namespace: bt({ code: Et() }).noUnknownFields(),
          primary: ht(),
          xid: Et(),
        }).noUnknownFields(),
      ).required(),
    ),
    St = bt({}),
    Pt = "alloy_debug",
    Dt = ({
      console: e,
      locationSearch: t,
      createLogger: n,
      instanceName: r,
      createNamespacedStorage: o,
      getMonitors: i,
    }) => {
      const a = ye.parse(t),
        s = o("instance." + r + "."),
        c = s.session.getItem("debug");
      let d = "true" === c,
        l = null === c;
      const u = () => d,
        p = (e, { fromConfig: t }) => {
          ((t && !l) || (d = e),
            t || (s.session.setItem("debug", e.toString()), (l = !1)));
        };
      var g;
      return (
        void 0 !== a[Pt] &&
          p(((g = a[Pt]), ce(g) && "true" === g.toLowerCase()), {
            fromConfig: !1,
          }),
        {
          setDebugEnabled: p,
          logger: n({
            getDebugEnabled: u,
            context: { instanceName: r },
            getMonitors: i,
            console: e,
          }),
          createComponentLogger: (t) =>
            n({
              getDebugEnabled: u,
              context: { instanceName: r, componentName: t },
              getMonitors: i,
              console: e,
            }),
        }
      );
    };
  const Rt = [
    "onComponentsRegistered",
    "onBeforeEvent",
    "onBeforeRequest",
    "onResponse",
    "onRequestFailure",
    "onClick",
    "onDecision",
  ];
  var Tt = (e) =>
    Rt.reduce((t, n) => {
      var r;
      return (
        (t[n] =
          ((r = (
            (e, t) =>
            (...n) =>
              Promise.all(
                e.getLifecycleCallbacks(t).map(
                  (e) =>
                    new Promise((t) => {
                      t(e(...n));
                    }),
                ),
              )
          )(e, n)),
          (...e) => Promise.resolve().then(() => r(...e)))),
        t
      );
    }, {});
  const Ot =
    (e, t) =>
    (...n) => {
      let r;
      try {
        r = e(...n);
      } catch (e) {
        throw be({ error: e, message: t });
      }
      return (
        r instanceof Promise &&
          (r = r.catch((e) => {
            throw be({ error: e, message: t });
          })),
        r
      );
    };
  var Nt = () => {
    const e = {},
      t = {},
      n = {};
    return {
      register(r, o) {
        const { commands: i, lifecycle: a } = o;
        (((e, n = {}) => {
          const r =
            ((o = Object.keys(t)),
            (i = Object.keys(n)),
            o.filter((e) => i.includes(e)));
          var o, i;
          if (r.length)
            throw new Error(
              "[ComponentRegistry] Could not register " +
                e +
                " because it has existing command(s): " +
                r.join(","),
            );
          Object.keys(n).forEach((r) => {
            const o = n[r];
            ((o.commandName = r),
              (o.run = Ot(
                o.run,
                "[" +
                  e +
                  "] An error occurred while executing the " +
                  r +
                  " command.",
              )),
              (t[r] = o));
          });
        })(r, i),
          ((e, t = {}) => {
            Object.keys(t).forEach((r) => {
              ((n[r] = n[r] || []),
                n[r].push(
                  Ot(
                    t[r],
                    "[" +
                      e +
                      "] An error occurred while executing the " +
                      r +
                      " lifecycle hook.",
                  ),
                ));
            });
          })(r, a),
          (e[r] = o));
      },
      getCommand: (e) => t[e],
      getCommandNames: () => Object.keys(t),
      getLifecycleCallbacks: (e) => n[e] || [],
      getComponentNames: () => Object.keys(e),
    };
  };
  const Mt = "in",
    At = "out",
    xt = "pending",
    qt = "general",
    Lt = "declinedConsent",
    Ut = "default",
    jt = "initial",
    _t = "new",
    Ft = (e) => {
      const t = new Error(e);
      return ((t.code = Lt), (t.message = e), t);
    };
  var Bt = ({ logger: e }) => {
    const t = [],
      n = () => Promise.resolve(),
      r = () => Promise.resolve(),
      o = () => Promise.reject(Ft("No consent preferences have been set.")),
      i = () => Promise.reject(Ft("The user declined consent.")),
      a = (e) => {
        if (e) return Promise.reject(new Error("Consent is pending."));
        const n = l();
        return (t.push(n), n.promise);
      };
    return {
      in(o) {
        o === Ut
          ? (this.awaitConsent = n)
          : (o === jt
              ? e.info(
                  "Loaded user consent preferences. The user previously consented.",
                )
              : o === _t &&
                this.awaitConsent !== r &&
                e.info("User consented."),
            (() => {
              for (; t.length; ) t.shift().resolve();
            })(),
            (this.awaitConsent = r));
      },
      out(n) {
        n === Ut
          ? (e.warn(
              "User consent preferences not found. Default consent of out will be used.",
            ),
            (this.awaitConsent = o))
          : (n === jt
              ? e.warn(
                  "Loaded user consent preferences. The user previously declined consent.",
                )
              : n === _t &&
                this.awaitConsent !== i &&
                e.warn("User declined consent."),
            (() => {
              for (; t.length; )
                t.shift().reject(Ft("The user declined consent."));
            })(),
            (this.awaitConsent = i));
      },
      pending(t) {
        (t === Ut &&
          e.info(
            "User consent preferences not found. Default consent of pending will be used. Some commands may be delayed.",
          ),
          (this.awaitConsent = a));
      },
      awaitConsent: () => Promise.resolve(),
      withConsent() {
        return this.awaitConsent(!0);
      },
      current() {
        switch (this.awaitConsent) {
          case n:
            return { state: "in", wasSet: !1 };
          case r:
            return { state: "in", wasSet: !0 };
          case o:
            return { state: "out", wasSet: !1 };
          case i:
            return { state: "out", wasSet: !0 };
          case a:
            return { state: "pending", wasSet: !1 };
          default:
            return { state: "in", wasSet: !1 };
        }
      },
    };
  };
  const Vt = (e) =>
    e &&
    e._experience &&
    e._experience.decisioning &&
    w(e._experience.decisioning.propositions)
      ? e._experience.decisioning.propositions
      : [];
  var Ht = () => {
    const e = {};
    let t,
      n,
      r = !1,
      o = !1,
      i = !0;
    const s = (e) => {
        if (o)
          throw new Error(e + " cannot be called after event is finalized.");
      },
      c = {
        hasQuery() {
          return Object.prototype.hasOwnProperty.call(
            this.getContent(),
            "query",
          );
        },
        getContent() {
          const r = JSON.parse(JSON.stringify(e));
          return (t && a(r, { xdm: t }), n && a(r, { data: n }), r);
        },
        setUserXdm(e) {
          (s("setUserXdm"), (t = e));
        },
        setUserData(e) {
          (s("setUserData"), (n = e));
        },
        mergeXdm(t) {
          (s("mergeXdm"), t && a(e, { xdm: t }));
        },
        mergeData(t) {
          (s("mergeData"), t && a(e, { data: t }));
        },
        mergeMeta(t) {
          (s("mergeMeta"), t && a(e, { meta: t }));
        },
        mergeQuery(t) {
          (s("mergeQuery"), t && a(e, { query: t }));
        },
        documentMayUnload() {
          r = !0;
        },
        finalize(r) {
          if (o) return;
          const a = ((e, t = u) =>
            e.filter(
              (n, r) =>
                ((e, t, n) => {
                  for (let r = 0; r < e.length; r += 1)
                    if (n(e[r], t)) return r;
                  return -1;
                })(e, n, t) === r,
            ))(
            [...Vt(t), ...Vt(e.xdm)],
            (e, t) =>
              e === t ||
              (e.id &&
                t.id &&
                e.id === t.id &&
                e.scope &&
                t.scope &&
                e.scope === t.scope),
          );
          if (
            (t && this.mergeXdm(t),
            a.length > 0 && (e.xdm._experience.decisioning.propositions = a),
            n && c.mergeData(n),
            (o = !0),
            r)
          ) {
            i = !1;
            const t = { xdm: e.xdm || {}, data: e.data || {} },
              n = r(t);
            ((i = !1 !== n),
              (e.xdm = t.xdm || {}),
              (e.data = t.data || {}),
              j(e.xdm) && delete e.xdm,
              j(e.data) && delete e.data);
          }
        },
        getDocumentMayUnload: () => r,
        isEmpty: () => j(e) && (!t || j(t)) && (!n || j(n)),
        shouldSend: () => i,
        getViewName() {
          if (t && t.web && t.web.webPageDetails)
            return t.web.webPageDetails.viewName;
        },
        toJSON() {
          if (!o) throw new Error("toJSON called before finalize");
          return e;
        },
      };
    return c;
  };
  const zt = "configure",
    Jt = "setDebug";
  var Gt = ({
    logger: e,
    configureCommand: n,
    setDebugCommand: r,
    handleError: o,
    validateCommandOptions: i,
  }) => {
    let a;
    return (s, c = {}) =>
      new Promise((t) => {
        const o = ((t, o) => {
          let s;
          if (t === zt) {
            if (a)
              throw new Error(
                "The library has already been configured and may only be configured once.",
              );
            s = () => ((a = n(o)), a.then(() => {}));
          } else {
            if (!a)
              throw new Error(
                "The library must be configured first. Please do so by executing the configure command.",
              );
            s =
              t === Jt
                ? () => {
                    const e = bt({
                        enabled: ht().required(),
                      }).noUnknownFields(),
                      t = i({
                        command: { commandName: Jt, optionsValidator: e },
                        options: o,
                      });
                    r(t);
                  }
                : () =>
                    a.then(
                      (e) => {
                        const n = e.getCommand(t);
                        if (!n || !v(n.run)) {
                          const n = [zt, Jt]
                            .concat(e.getCommandNames())
                            .join(", ");
                          throw new Error(
                            "The " +
                              t +
                              " command does not exist. List of available commands: " +
                              n +
                              ".",
                          );
                        }
                        const r = i({ command: n, options: o });
                        return n.run(r);
                      },
                      () => (
                        e.warn(
                          "An error during configuration is preventing the " +
                            t +
                            " command from executing.",
                        ),
                        new Promise(() => {})
                      ),
                    );
          }
          return s;
        })(s, c);
        (e.logOnBeforeCommand({ commandName: s, options: c }), t(o()));
      })
        .catch((e) => o(e, s + " command"))
        .catch((t) => {
          throw (
            e.logOnCommandRejected({ commandName: s, options: c, error: t }),
            t
          );
        })
        .then((n) => {
          const r = t(n) ? n : {};
          return (
            e.logOnCommandResolved({ commandName: s, options: c, result: r }),
            r
          );
        });
  };
  const Qt = "https://adobe.ly/3sHgQHb";
  var Xt = ({ command: e, options: t }) => {
    const { commandName: n, documentationUri: r = Qt, optionsValidator: o } = e;
    let i = t;
    if (o)
      try {
        i = o(t);
      } catch (e) {
        throw new Error(
          "Invalid " +
            n +
            " command options:\n\t - " +
            e +
            " For command documentation see: " +
            r,
        );
      }
    return i;
  };
  var Wt = ({
    options: e,
    componentCreators: t,
    coreConfigValidators: n,
    createConfig: r,
    logger: o,
    setDebugEnabled: i,
  }) => {
    const a = ((e) => {
        const t = [],
          n = {
            get enabled() {
              return e.enabled;
            },
            flush() {
              t.forEach(({ method: t, args: n }) => e[t](...n));
            },
          };
        return (
          Object.keys(e)
            .filter((t) => "function" == typeof e[t])
            .forEach((e) => {
              n[e] = (...n) => {
                t.push({ method: e, args: n });
              };
            }),
          n
        );
      })(o),
      s = t
        .map(({ configValidators: e }) => e)
        .filter((e) => e)
        .reduce((e, t) => e.concat(t), n),
      c = r(
        (({ combinedConfigValidator: e, options: t, logger: n }) => {
          try {
            return e.noUnknownFields().required().call({ logger: n }, t);
          } catch (e) {
            throw new Error(
              "Resolve these configuration problems:\n\t - " +
                e.message.split("\n").join("\n\t - ") +
                "\nFor configuration documentation see: https://adobe.ly/3sHh553",
            );
          }
        })({ combinedConfigValidator: s, options: e, logger: a }),
      );
    (i(c.debugEnabled, { fromConfig: !0 }), a.flush());
    const d = ((e, t, n) =>
      n.reduce(
        (n, { buildOnInstanceConfiguredExtraParams: r }) => (
          r && (n = { ...n, ...r({ config: e, logger: t }) }),
          n
        ),
        {},
      ))(c, o, t);
    return (o.logOnInstanceConfigured({ ...d, config: c }), c);
  };
  const Yt = (e) => ({ ...e });
  var Kt =
      ({ errorPrefix: e, logger: t }) =>
      (n, r) => {
        const o = we(n);
        if (o.code === Lt)
          return (
            t.warn("The " + r + " could not fully complete. " + o.message),
            {}
          );
        throw (Ie({ error: o, message: e + " " + o.message }), o);
      },
    $t = ({ getDebugEnabled: e, console: t, getMonitors: n, context: r }) => {
      let o = "[" + r.instanceName + "]";
      r.componentName && (o += " [" + r.componentName + "]");
      const i = (e, t) => {
          const o = n();
          if (o.length > 0) {
            const n = { ...r, ...t };
            o.forEach((t) => {
              t[e] && t[e](n);
            });
          }
        },
        a = (n, ...r) => {
          (i("onBeforeLog", { level: n, arguments: r }), e() && t[n](o, ...r));
        };
      return {
        get enabled() {
          return n().length > 0 || e();
        },
        logOnInstanceCreated(e) {
          (i("onInstanceCreated", e), a("info", "Instance initialized."));
        },
        logOnInstanceConfigured(e) {
          (i("onInstanceConfigured", e),
            a(
              "info",
              "Instance configured. Computed configuration:",
              e.config,
            ));
        },
        logOnBeforeCommand(e) {
          (i("onBeforeCommand", e),
            a(
              "info",
              "Executing " + e.commandName + " command. Options:",
              e.options,
            ));
        },
        logOnCommandResolved(e) {
          (i("onCommandResolved", e),
            a("info", e.commandName + " command resolved. Result:", e.result));
        },
        logOnCommandRejected(e) {
          (i("onCommandRejected", e),
            a(
              "error",
              e.commandName + " command was rejected. Error:",
              e.error,
            ));
        },
        logOnBeforeNetworkRequest(e) {
          (i("onBeforeNetworkRequest", e),
            a(
              "info",
              "Request " + e.requestId + ": Sending request.",
              e.payload,
            ));
        },
        logOnNetworkResponse(e) {
          i("onNetworkResponse", e);
          const t =
            e.parsedBody || e.body ? "response body:" : "no response body.";
          a(
            "info",
            "Request " +
              e.requestId +
              ": Received response with status code " +
              e.statusCode +
              " and " +
              t,
            e.parsedBody || e.body,
          );
        },
        logOnNetworkError(e) {
          (i("onNetworkError", e),
            a(
              "error",
              "Request " + e.requestId + ": Network request failed.",
              e.error,
            ));
        },
        logOnContentHiding(e) {
          (i("onContentHiding", { status: e.status }),
            a(e.logLevel, e.message));
        },
        logOnContentRendering(e) {
          (i("onContentRendering", { status: e.status, payload: e.detail }),
            a(e.logLevel, e.message));
        },
        info: a.bind(null, "info"),
        warn: a.bind(null, "warn"),
        error: a.bind(null, "error"),
      };
    },
    Zt = "__view__",
    en = (e) => (t, n) => {
      ((e.xdm = e.xdm || {}),
        (e.xdm.identityMap = e.xdm.identityMap || {}),
        (e.xdm.identityMap[t] = e.xdm.identityMap[t] || []),
        e.xdm.identityMap[t].push(n));
    },
    tn = (e) => {
      const {
          payload: t,
          getAction: n,
          getUseSendBeacon: r,
          datastreamIdOverride: o,
          edgeSubPath: i,
        } = e,
        a = Re();
      let s = !1,
        c = !1;
      return {
        getId: () => a,
        getPayload: () => t,
        getAction: () => n({ isIdentityEstablished: c }),
        getDatastreamIdOverride: () => o,
        getUseSendBeacon: () => r({ isIdentityEstablished: c }),
        getEdgeSubPath: () => i || "",
        getUseIdThirdPartyDomain: () => s,
        setUseIdThirdPartyDomain() {
          s = !0;
        },
        setIsIdentityEstablished() {
          c = !0;
        },
      };
    },
    nn = ({ payload: e, datastreamIdOverride: t }) => {
      const n = ({ isIdentityEstablished: t }) => e.getDocumentMayUnload() && t;
      return tn({
        payload: e,
        getAction: ({ isIdentityEstablished: e }) =>
          n({ isIdentityEstablished: e }) ? "collect" : "interact",
        getUseSendBeacon: n,
        datastreamIdOverride: t,
      });
    },
    rn = (t) => {
      const { content: n, addIdentity: r, hasIdentity: o } = t,
        i = s(n, "meta.configOverrides");
      return {
        mergeMeta: s(n, "meta"),
        mergeState: s(n, "meta.state"),
        mergeQuery: s(n, "query"),
        mergeConfigOverride: (t) =>
          i(
            ((t) => {
              if (e(t) || "object" != typeof t) return null;
              const n = _(
                t,
                (t) => !(e(t) || (!ie(t) && !ae(t) && !de(t) && !w(t))),
              );
              return j(n) ? null : n;
            })(t),
          ),
        addIdentity: r,
        hasIdentity: o,
        toJSON: () => n,
      };
    },
    on = (e) => (t) =>
      void 0 !== (e.xdm && e.xdm.identityMap && e.xdm.identityMap[t]),
    an = () => {
      const e = {},
        t = rn({ content: e, addIdentity: en(e), hasIdentity: on(e) });
      return (
        (t.addEvent = (t) => {
          ((e.events = e.events || []), e.events.push(t));
        }),
        (t.getDocumentMayUnload = () =>
          (e.events || []).some((e) => e.getDocumentMayUnload())),
        t
      );
    },
    sn = ({
      localConfigOverrides: e,
      globalConfigOverrides: t,
      payload: n,
    }) => {
      const r = { payload: n },
        { datastreamId: o, ...i } = e || {};
      return (
        o && (r.datastreamIdOverride = o),
        t && !j(t) && n.mergeConfigOverride(t),
        i && !j(i) && n.mergeConfigOverride(i),
        r
      );
    };
  const cn = "clientId";
  const dn =
    "Event was canceled because the onBeforeEventSend callback returned false.";
  var ln =
    ({ orgId: e, targetMigrationEnabled: t }) =>
    (n) =>
      ((e, t) => 0 === t.indexOf(H + "_" + z(e) + "_"))(e, n) ||
      "at_qa_mode" === n ||
      (t && "mbox" === n);
  var un = (e) =>
      ((...e) =>
        e.length < 2
          ? Object.assign(...e)
          : e.reduce(
              (e, n) => (
                t(n) &&
                  Object.keys(n).forEach((t) => {
                    Array.isArray(n[t])
                      ? Array.isArray(e[t])
                        ? e[t].push(...n[t])
                        : (e[t] = [...n[t]])
                      : (e[t] = n[t]);
                  }),
                e
              ),
            ))({}, ...(e.shift() || []), ...(e.shift() || []), ...e),
    pn = (e) => (t) => {
      const n = () => {
        throw t;
      };
      return e.call({ error: t }).then(n, n);
    };
  const gn = "The server responded with a";
  var mn = ({ orgId: e, cookieJar: t }) => {
    const n = J(e, "cluster");
    return () =>
      t.get(n) ||
      (() => {
        const e = t.get("mboxEdgeCluster");
        if (e) return "t" + e;
      })();
  };
  const fn = [429, 503, 502, 504];
  var hn = ({ response: e, retriesAttempted: t }) =>
    t < 3 && fn.includes(e.statusCode);
  var yn = ({ response: e, retriesAttempted: t }) => {
    let n = ((e) => {
      const t = e.getHeader("Retry-After");
      let n;
      if (t) {
        const e = parseInt(t, 10);
        n = se(e)
          ? 1e3 * e
          : Math.max(0, new Date(t).getTime() - new Date().getTime());
      }
      return n;
    })(e);
    return (
      void 0 === n &&
        (n = ((e) => {
          const t = 1e3 + 1e3 * e,
            n = 0.3 * t,
            r = t - n,
            o = t + n;
          return Math.round(r + Math.random() * (o - r));
        })(t)),
      n
    );
  };
  var vn = (e) => {
    let t = window.__alloyMonitors || [];
    return (e && (t = t.concat(e)), t);
  };
  var wn = (e) => (t) => {
      const n = e().toISOString();
      a(t, { timestamp: n });
    },
    In = "2.28.1",
    bn = [
      ["architecture", "string"],
      ["bitness", "string"],
      ["model", "string"],
      ["platformVersion", "string"],
      ["wow64", "boolean"],
    ];
  const En = ((e) => (t) => {
      const n = {
        webPageDetails: { URL: e.location.href || e.location },
        webReferrer: { URL: e.document.referrer },
      };
      a(t, { web: n });
    })(window),
    Cn = ((e) => (t) => {
      const {
          screen: { width: n, height: r },
        } = e,
        o = {},
        i = Ee(r);
      i >= 0 && (o.screenHeight = i);
      const s = Ee(n);
      s >= 0 && (o.screenWidth = s);
      const c =
        ((e) => {
          const {
            screen: { orientation: t },
          } = e;
          if (null == t || null == t.type) return null;
          const n = t.type.split("-");
          return 0 === n.length || ("portrait" !== n[0] && "landscape" !== n[0])
            ? null
            : n[0];
        })(e) ||
        ((e) => {
          if (v(e.matchMedia)) {
            if (e.matchMedia("(orientation: portrait)").matches)
              return "portrait";
            if (e.matchMedia("(orientation: landscape)").matches)
              return "landscape";
          }
          return null;
        })(e);
      (c && (o.screenOrientation = c),
        Object.keys(o).length > 0 && a(t, { device: o }));
    })(window),
    kn = ((e) => (t) => {
      const {
          document: {
            documentElement: { clientWidth: n, clientHeight: r } = {},
          },
        } = e,
        o = { type: "browser" },
        i = Ee(n);
      i >= 0 && (o.browserDetails = { viewportWidth: i });
      const s = Ee(r);
      (s >= 0 &&
        ((o.browserDetails = o.browserDetails || {}),
        (o.browserDetails.viewportHeight = s)),
        a(t, { environment: o }));
    })(window),
    Sn =
      ((Pn = () => new Date()),
      (e) => {
        const t = Pn(),
          n = {},
          r = Ee(t.getTimezoneOffset());
        (void 0 !== r && (n.localTimezoneOffset = r),
          (void 0 === r || Math.abs(r) < 6e3) &&
            (n.localTime = ((e) => {
              const t = e.getFullYear(),
                n = Ce(e.getMonth() + 1, 2, "0"),
                r = Ce(e.getDate(), 2, "0"),
                o = Ce(e.getHours(), 2, "0"),
                i = Ce(e.getMinutes(), 2, "0"),
                a = Ce(e.getSeconds(), 2, "0"),
                s = Ce(e.getMilliseconds(), 3, "0"),
                c = Ee(e.getTimezoneOffset(), 0);
              return (
                t +
                "-" +
                n +
                "-" +
                r +
                "T" +
                o +
                ":" +
                i +
                ":" +
                a +
                "." +
                s +
                (c > 0 ? "-" : "+") +
                Ce(Math.floor(Math.abs(c) / 60), 2, "0") +
                ":" +
                Ce(Math.abs(c) % 60, 2, "0")
              );
            })(t)),
          a(e, { placeContext: n }));
      });
  var Pn;
  const Dn = wn(() => new Date()),
    Rn = { web: En, device: Cn, environment: kn, placeContext: Sn },
    Tn = {
      highEntropyUserAgentHints: ((e) =>
        ((e) => "userAgentData" in e)(e)
          ? (t, n) => {
              try {
                return e.userAgentData
                  .getHighEntropyValues(bn.map((e) => e[0]))
                  .then((e) => {
                    const n = {};
                    (bn.forEach(([t, r]) => {
                      Object.prototype.hasOwnProperty.call(e, t) &&
                        typeof e[t] === r &&
                        (n[t] = e[t]);
                    }),
                      a(t, {
                        environment: {
                          browserDetails: { userAgentClientHints: n },
                        },
                      }));
                  });
              } catch (e) {
                return (
                  n.warn(
                    "Unable to collect user-agent client hints. " + e.message,
                  ),
                  le
                );
              }
            }
          : le)(navigator),
    },
    On = { ...Rn, ...Tn },
    Nn = [
      Dn,
      (e) => {
        a(e, {
          implementationDetails: {
            name: "https://ns.adobe.com/experience/alloy",
            version: In,
            environment: "browser",
          },
        });
      },
    ],
    Mn = ({ config: e, logger: t }) =>
      ((e, t, n, r) => {
        const o = e.context
          .flatMap((e, r) =>
            n[e]
              ? [n[e]]
              : (t.warn(
                  "Invalid context[" + r + "]: '" + e + "' is not available.",
                ),
                []),
          )
          .concat(r);
        return {
          namespace: "Context",
          lifecycle: {
            onBeforeEvent({ event: e }) {
              const n = {};
              return Promise.all(o.map((e) => Promise.resolve(e(n, t)))).then(
                () => e.mergeXdm(n),
              );
            },
          },
        };
      })(e, t, On, Nn);
  ((Mn.namespace = "Context"),
    (Mn.configValidators = bt({ context: ft(Et()).default(Object.keys(Rn)) })));
  const An = ({ eventManager: e, logger: t }) => ({
    commands: {
      sendEvent: {
        documentationUri: "https://adobe.ly/3GQ3Q7t",
        optionsValidator: (e) =>
          (({ options: e }) =>
            bt({
              type: Et(),
              xdm: bt({ eventType: Et(), identityMap: kt }),
              data: bt({}),
              documentUnloading: ht(),
              renderDecisions: ht(),
              decisionScopes: ft(Et()).uniqueItems(),
              personalization: bt({
                decisionScopes: ft(Et()).uniqueItems(),
                surfaces: ft(Et()).uniqueItems(),
                sendDisplayEvent: ht().default(!0),
                includeRenderedPropositions: ht().default(!1),
                defaultPersonalizationEnabled: ht(),
                decisionContext: bt({}),
              }).default({ sendDisplayEvent: !0 }),
              datasetId: Et(),
              mergeId: Et(),
              edgeConfigOverrides: St,
            })
              .required()
              .noUnknownFields()(e))({ options: e }),
        run: (n) => {
          const {
              xdm: r,
              data: o,
              documentUnloading: i,
              type: s,
              mergeId: c,
              datasetId: d,
              edgeConfigOverrides: l,
              ...u
            } = n,
            p = e.createEvent();
          return (
            i && p.documentMayUnload(),
            p.setUserXdm(r),
            p.setUserData(o),
            s && p.mergeXdm({ eventType: s }),
            c && p.mergeXdm({ eventMergeId: c }),
            l && (u.edgeConfigOverrides = l),
            d &&
              (t.warn(
                "The 'datasetId' option has been deprecated. Please use 'edgeConfigOverrides.com_adobe_experience_platform.datasets.event.datasetId' instead.",
              ),
              (u.edgeConfigOverrides = l || {}),
              a(u.edgeConfigOverrides, {
                com_adobe_experience_platform: {
                  datasets: { event: { datasetId: d } },
                },
              })),
            e.sendEvent(p, u)
          );
        },
      },
      applyResponse: {
        documentationUri: "",
        optionsValidator: (e) =>
          (({ options: e }) =>
            bt({
              renderDecisions: ht(),
              responseHeaders: It(Et().required()),
              responseBody: bt({
                handle: ft(
                  bt({ type: Et().required(), payload: mt().required() }),
                ).required(),
              }).required(),
              personalization: bt({
                sendDisplayEvent: ht().default(!0),
                decisionContext: bt({}),
              }).default({ sendDisplayEvent: !0 }),
            }).noUnknownFields()(e))({ options: e }),
        run: (t) => {
          const {
              renderDecisions: n = !1,
              decisionContext: r = {},
              responseHeaders: o = {},
              responseBody: i = { handle: [] },
              personalization: a,
            } = t,
            s = e.createEvent();
          return e.applyResponse(s, {
            renderDecisions: n,
            decisionContext: r,
            responseHeaders: o,
            responseBody: i,
            personalization: a,
          });
        },
      },
    },
  });
  An.namespace = "DataCollector";
  const xn = (e, t) =>
    "ID sync " + (t ? "succeeded" : "failed") + ": " + e.spec.url;
  const qn = bt({
    thirdPartyCookiesEnabled: ht().default(!0),
    idMigrationEnabled: ht().default(!0),
  });
  var Ln = bt({ url: Et().required().nonEmpty(), edgeConfigOverrides: St })
      .required()
      .noUnknownFields(),
    Un = "ECID",
    jn = ({ logger: e }) =>
      new Promise((n, r) => {
        if (t(window.adobe) && t(window.adobe.optIn)) {
          const t = window.adobe.optIn;
          (e.info(
            "Delaying request while waiting for legacy opt-in to let Visitor retrieve ECID from server.",
          ),
            t.fetchPermissions(() => {
              t.isApproved([t.Categories.ECID])
                ? (e.info(
                    "Received legacy opt-in approval to let Visitor retrieve ECID from server.",
                  ),
                  n())
                : r(new Error("Legacy opt-in was declined."));
            }, !0));
        } else n();
      }),
    _n =
      ({ logger: e, orgId: t, awaitVisitorOptIn: n }) =>
      () => {
        const r = ((e) => {
          const t = e.Visitor;
          return v(t) && v(t.getInstance) && t;
        })(window);
        return r
          ? n({ logger: e })
              .then(
                () => (
                  e.info(
                    "Delaying request while using Visitor to retrieve ECID from server.",
                  ),
                  new Promise((n) => {
                    r.getInstance(t, {}).getMarketingCloudVisitorID((t) => {
                      (e.info(
                        "Resuming previously delayed request that was waiting for ECID from Visitor.",
                      ),
                        n(t));
                    }, !0);
                  })
                ),
              )
              .catch((t) => {
                t
                  ? e.info(t.message + ", retrieving ECID from experience edge")
                  : e.info(
                      "An error occurred while obtaining the ECID from Visitor.",
                    );
              })
          : Promise.resolve();
      },
    Fn = "CORE",
    Bn = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return "";
      }
    };
  var Vn = (e, t) => {
      e.addIdentity(Un, { id: t });
    },
    Hn = (e) =>
      e
        .getPayloadsByType("identity:result")
        .reduce(
          (e, t) => (
            t.namespace && t.namespace.code && (e[t.namespace.code] = t.id),
            e
          ),
          {},
        ),
    zn = ({ payload: e, datastreamIdOverride: t }) =>
      tn({
        payload: e,
        datastreamIdOverride: t,
        getAction: () => "identity/acquire",
        getUseSendBeacon: () => !1,
      }),
    Jn = (e) => {
      const t = { query: { identity: { fetch: e } } };
      return rn({ content: t, addIdentity: en(t), hasIdentity: on(t) });
    };
  const Gn = /^([^?#]*)(\??[^#]*)(#?.*)$/;
  const Qn = bt({
    namespaces: ft(Ct(Un, Fn)).nonEmpty().uniqueItems().default([Un]),
    edgeConfigOverrides: St,
  })
    .noUnknownFields()
    .default({ namespaces: [Un] });
  const Xn = (e, t) => {
      let n,
        r = 0,
        o = 0;
      do {
        if (t < 0 || t + o >= e.length)
          throw new Error("Invalid varint: buffer ended unexpectedly");
        if (((n = e[t + o]), (r |= (127 & n) << (7 * o)), (o += 1), o > 10))
          throw new Error("Invalid varint: too long");
      } while (128 & n);
      return { value: r, length: o };
    },
    Wn = Object.freeze({
      VARINT: 0,
      I64: 1,
      LEN: 2,
      SGROUP: 3,
      EGROUP: 4,
      I32: 5,
    });
  var Yn = ({ orgId: e, cookieJar: t, logger: n }) => {
    const r = J(e, "identity");
    return () => {
      const e = t.get(r);
      if (!e) return null;
      try {
        const t = decodeURIComponent(e).replace(/_/g, "/").replace(/-/g, "+");
        return ((e) => {
          let t = 0,
            n = null;
          for (; t < e.length && !n; ) {
            const { value: r, length: o } = Xn(e, t);
            t += o;
            const i = 7 & r;
            if (1 == r >> 3) {
              if (i === Wn.LEN) {
                const r = Xn(e, t);
                return (
                  (t += r.length),
                  (n = new TextDecoder().decode(e.slice(t, t + r.value))),
                  (t += r.value),
                  n
                );
              }
            } else
              switch (i) {
                case Wn.VARINT:
                  t += Xn(e, t).length;
                  break;
                case Wn.I64:
                  t += 8;
                  break;
                case Wn.LEN: {
                  const n = Xn(e, t);
                  t += n.length + n.value;
                  break;
                }
                case Wn.SGROUP:
                case Wn.EGROUP:
                  break;
                case Wn.I32:
                  t += 4;
                  break;
                default:
                  throw new Error(
                    "Malformed kndctr cookie. Unknown wire type: " + i,
                  );
              }
          }
          throw new Error("No ECID found in cookie.");
        })(
          ((e) => {
            const t = atob(e);
            return Uint8Array.from(t, (e) => e.codePointAt(0));
          })(t),
        );
      } catch (e) {
        return (n.warn("Unable to decode ECID from " + r + " cookie", e), null);
      }
    };
  };
  const Kn = ({
    config: e,
    logger: t,
    consent: n,
    fireReferrerHideableImage: r,
    sendEdgeNetworkRequest: i,
    apexDomain: a,
    getBrowser: s,
  }) => {
    const { orgId: c, thirdPartyCookiesEnabled: l, edgeConfigOverrides: u } = e,
      p = _n({ logger: t, orgId: c, awaitVisitorOptIn: jn }),
      g = d({ logger: t, cookieJar: o }),
      m = (({
        config: e,
        getEcidFromVisitor: t,
        apexDomain: n,
        isPageSsl: r,
        cookieJar: o,
      }) => {
        const { idMigrationEnabled: i, orgId: a } = e,
          s = "AMCV_" + a,
          c = () => {
            let e = null;
            const t = o.get("s_ecid") || o.get(s);
            if (t) {
              const n = /(^|\|)MCMID\|(\d+)($|\|)/,
                r = t.match(n);
              r && (e = r[2]);
            }
            return e;
          };
        return {
          getEcid() {
            if (i) {
              const e = c();
              return e ? Promise.resolve(e) : t();
            }
            return Promise.resolve();
          },
          setEcid(e) {
            if (i && c() !== e) {
              const t = r ? { sameSite: "none", secure: !0 } : {};
              o.set(s, "MCMID|" + e, { domain: n, expires: 390, ...t });
            }
          },
        };
      })({
        config: e,
        getEcidFromVisitor: p,
        apexDomain: a,
        cookieJar: g,
        isPageSsl: "https:" === window.location.protocol,
      }),
      f = ne({ orgId: c }),
      h = (
        ({
          sendEdgeNetworkRequest: e,
          createIdentityRequestPayload: t,
          createIdentityRequest: n,
          globalConfigOverrides: r,
        }) =>
        ({ namespaces: o, edgeConfigOverrides: i } = {}) => {
          const a = sn({
              payload: t(o),
              globalConfigOverrides: r,
              localConfigOverrides: i,
            }),
            s = n(a);
          return e({ request: s });
        }
      )({
        sendEdgeNetworkRequest: i,
        createIdentityRequestPayload: Jn,
        createIdentityRequest: zn,
        globalConfigOverrides: u,
      }),
      y = (({ getBrowser: e }) => ee(() => te.includes(e())))({
        getBrowser: s,
      }),
      v = (
        ({
          thirdPartyCookiesEnabled: e,
          areThirdPartyCookiesSupportedByDefault: t,
        }) =>
        (n) => {
          e && t() && n.setUseIdThirdPartyDomain();
        }
      )({
        thirdPartyCookiesEnabled: l,
        areThirdPartyCookiesSupportedByDefault: y,
      }),
      w = (
        ({ getLegacyEcid: e, addEcidToPayload: t }) =>
        (n) =>
          n.hasIdentity(Un)
            ? Promise.resolve()
            : e().then((e) => {
                e && t(n, e);
              })
      )({ getLegacyEcid: m.getEcid, addEcidToPayload: Vn }),
      I = (
        ({ locationSearch: e, dateProvider: t, orgId: n, logger: r }) =>
        (o) => {
          if (o.hasIdentity(Un)) return;
          let i = ye.parse(e).adobe_mc;
          if (void 0 === i) return;
          Array.isArray(i) &&
            (r.warn(
              "Found multiple adobe_mc query string paramters, only using the last one.",
            ),
            (i = i[i.length - 1]));
          const a = i.split("|").reduce((e, t) => {
              const [n, r] = t.split("=");
              return (
                (e[n] = Bn(r)),
                (e[n] = e[n].replace(/[^a-zA-Z0-9@.]/g, "")),
                e
              );
            }, {}),
            s = parseInt(a.TS, 10),
            c = a.MCMID,
            d = Bn(a.MCORGID);
          t().getTime() / 1e3 <= s + 300 && d === n && c
            ? (r.info(
                "Found valid ECID identity " +
                  c +
                  " from the adobe_mc query string parameter.",
              ),
              o.addIdentity(Un, { id: c }))
            : r.info(
                "Detected invalid or expired adobe_mc query string parameter.",
              );
        }
      )({
        locationSearch: window.document.location.search,
        dateProvider: () => new Date(),
        orgId: c,
        logger: t,
      }),
      b = (
        ({ doesIdentityCookieExist: e, orgId: t, logger: n }) =>
        ({ onResponse: r, onRequestFailure: o }) =>
          new Promise((i, a) => {
            (r(() => {
              e()
                ? i()
                : (n.warn(
                    "Identity cookie not found. This could be caused by any of the following issues:\n\t* The org ID " +
                      t +
                      " configured in Alloy doesn't match the org ID specified in the edge configuration.\n\t* Experience edge was not able to set the identity cookie due to domain or cookie restrictions.\n\t* The request was canceled by the browser and not fully processed.",
                  ),
                  a(new Error("Identity cookie not found.")));
            }),
              o(() => {
                e() ? i() : a(new Error("Identity cookie not found."));
              }));
          })
      )({ doesIdentityCookieExist: f, orgId: c, logger: t }),
      E = (({
        doesIdentityCookieExist: e,
        setDomainForInitialIdentityPayload: t,
        addLegacyEcidToPayload: n,
        awaitIdentityCookie: r,
        logger: o,
      }) => {
        let i;
        const a = (e) => (t(e), n(e.getPayload()));
        return ({ request: t, onResponse: n, onRequestFailure: s }) => {
          if (e()) return (t.setIsIdentityEstablished(), Promise.resolve());
          if (i) {
            o.info("Delaying request while retrieving ECID from server.");
            const e = i;
            return (
              (i = e.catch(() => r({ onResponse: n, onRequestFailure: s }))),
              i.catch(() => {}),
              e
                .then(() => {
                  (o.info("Resuming previously delayed request."),
                    t.setIsIdentityEstablished());
                })
                .catch(() => a(t))
            );
          }
          return (
            (i = r({ onResponse: n, onRequestFailure: s })),
            i.catch(() => {}),
            a(t)
          );
        };
      })({
        doesIdentityCookieExist: f,
        setDomainForInitialIdentityPayload: v,
        addLegacyEcidToPayload: w,
        awaitIdentityCookie: b,
        logger: t,
      }),
      C = (
        ({ fireReferrerHideableImage: e, logger: t }) =>
        (n) => {
          const r = n.filter((e) => "url" === e.type);
          return r.length
            ? Promise.all(
                r.map((n) =>
                  e(n.spec)
                    .then(() => {
                      t.info(xn(n, !0));
                    })
                    .catch(() => {
                      t.error(xn(n, !1));
                    }),
                ),
              ).then(le)
            : Promise.resolve();
        }
      )({ fireReferrerHideableImage: r, logger: t }),
      k = (
        ({ processIdSyncs: e }) =>
        (t) =>
          e(t.getPayloadsByType("identity:exchange"))
      )({ processIdSyncs: C }),
      S = (
        ({ dateProvider: e, orgId: t }) =>
        (n, r) => {
          const o = Math.round(e().getTime() / 1e3),
            i = encodeURIComponent(
              "TS=" + o + "|MCMID=" + n + "|MCORGID=" + encodeURIComponent(t),
            ),
            [, a, s, c] = r.match(Gn),
            d = ((e) => ("" === e ? "?" : "?" === e ? "" : "&"))(s);
          return "" + a + s + d + "adobe_mc=" + i + c;
        }
      )({ dateProvider: () => new Date(), orgId: c }),
      P = (
        ({ thirdPartyCookiesEnabled: e }) =>
        (t) => {
          const n = Qn(t);
          if (!e && n.namespaces.includes(Fn))
            throw new Error(
              "namespaces: The CORE namespace cannot be requested when third-party cookies are disabled.",
            );
          return n;
        }
      )({ thirdPartyCookiesEnabled: l }),
      D = (({
        thirdPartyCookiesEnabled: e,
        areThirdPartyCookiesSupportedByDefault: t,
      }) => {
        const n = { identity: { fetch: [Un] } };
        return (
          e && t() && n.identity.fetch.push(Fn),
          (e) => {
            e.mergeQuery(n);
          }
        );
      })({
        thirdPartyCookiesEnabled: l,
        areThirdPartyCookiesSupportedByDefault: y,
      }),
      R = Yn({ orgId: c, cookieJar: g, logger: t });
    return (({
      addEcidQueryToPayload: e,
      addQueryStringIdentityToPayload: t,
      ensureSingleIdentity: n,
      setLegacyEcid: r,
      handleResponseForIdSyncs: o,
      getNamespacesFromResponse: i,
      getIdentity: a,
      consent: s,
      appendIdentityToUrl: c,
      logger: d,
      getIdentityOptionsValidator: l,
      decodeKndctrCookie: u,
    }) => {
      let p,
        g = {};
      return {
        lifecycle: {
          onBeforeRequest: ({
            request: r,
            onResponse: o,
            onRequestFailure: i,
          }) => (
            e(r.getPayload()),
            t(r.getPayload()),
            n({ request: r, onResponse: o, onRequestFailure: i })
          ),
          onResponse({ response: e }) {
            const t = i(e);
            return (
              (p && p[Un]) || !t || !t[Un] || r(t[Un]),
              t && Object.keys(t).length > 0 && (p = { ...p, ...t }),
              (g = { ...g, ...e.getEdge() }),
              o(e)
            );
          },
        },
        commands: {
          getIdentity: {
            optionsValidator: l,
            run: (e) => {
              const { namespaces: t } = e;
              return s
                .awaitConsent()
                .then(() => {
                  if (p) return;
                  const n = u();
                  return n &&
                    t.includes(Un) &&
                    (p || (p = {}), (p[Un] = n), 1 === t.length)
                    ? void 0
                    : a(e);
                })
                .then(() => ({
                  identity: t.reduce((e, t) => ((e[t] = p[t] || null), e), {}),
                  edge: g,
                }));
            },
          },
          appendIdentityToUrl: {
            optionsValidator: Ln,
            run: (e) =>
              s
                .withConsent()
                .then(() => {
                  if (p) return;
                  const t = u();
                  return t ? (p || (p = {}), void (p[Un] = t)) : a(e);
                })
                .then(() => ({ url: c(p[Un], e.url) }))
                .catch(
                  (t) => (
                    d.warn("Unable to append identity to url. " + t.message),
                    e
                  ),
                ),
          },
        },
      };
    })({
      addEcidQueryToPayload: D,
      addQueryStringIdentityToPayload: I,
      ensureSingleIdentity: E,
      setLegacyEcid: m.setEcid,
      handleResponseForIdSyncs: k,
      getNamespacesFromResponse: Hn,
      getIdentity: h,
      consent: n,
      appendIdentityToUrl: S,
      logger: t,
      getIdentityOptionsValidator: P,
      decodeKndctrCookie: R,
    });
  };
  ((Kn.namespace = "Identity"), (Kn.configValidators = qn));
  const $n = ({ config: e, componentRegistry: t }) => {
      const n = [...t.getCommandNames(), zt, Jt].sort(),
        r = { ...e };
      Object.keys(e).forEach((t) => {
        const n = e[t];
        "function" == typeof n && (r[t] = n.toString());
      });
      const o = t.getComponentNames();
      return { version: In, configs: r, commands: n, components: o };
    },
    Zn = ({ config: e, componentRegistry: t }) => ({
      commands: {
        getLibraryInfo: {
          run: () => ({ libraryInfo: $n({ config: e, componentRegistry: t }) }),
        },
      },
    });
  Zn.namespace = "LibraryInfo";
  var er = Object.freeze({
    __proto__: null,
    context: Mn,
    dataCollector: An,
    identity: Kn,
    libraryInfo: Zn,
  });
  const tr = oe(window),
    { console: nr, fetch: rr, navigator: or } = window,
    ir = bt({
      debugEnabled: ht().default(!1),
      datastreamId: Et().unique().required(),
      edgeDomain: Et().domain().default("edge.adobedc.net"),
      edgeBasePath: Et().nonEmpty().default("ee"),
      orgId: Et().unique().required(),
      onBeforeEventSend: yt().default(le),
      edgeConfigOverrides: St,
    }).renamed("edgeConfigId", Et().unique(), "datastreamId"),
    ar = ((e, t) => {
      let n = "";
      const r = e.location.hostname.toLowerCase().split(".");
      let o = 1;
      for (; o < r.length && !t.get(V); )
        ((o += 1),
          (n = ((i = r), (a = o), i.slice(-a)).join(".")),
          t.set(V, V, { domain: n }));
      var i, a;
      return (t.remove(V, { domain: n }), n);
    })(window, o),
    sr = (
      ({ fetch: e }) =>
      (t, n) =>
        e(t, {
          method: "POST",
          cache: "no-cache",
          credentials: "include",
          headers: { "Content-Type": "text/plain; charset=UTF-8" },
          referrerPolicy: "no-referrer-when-downgrade",
          body: n,
        }).then((e) =>
          e
            .text()
            .then((t) => ({
              statusCode: e.status,
              getHeader: (t) => e.headers.get(t),
              body: t,
            })),
        )
    )({ fetch: rr }),
    cr = (({
      appendNode: e = p,
      awaitSelector: t = N,
      createNode: n = g,
      fireImage: r = y,
    } = {}) => {
      const o = r;
      let i;
      const a = ({ src: o }) =>
        t("BODY")
          .then(([t]) => i || ((i = n("IFRAME", L, U)), e(t, i)))
          .then((e) => {
            const t = e.contentWindow.document;
            return r({ src: o, currentDocument: t });
          });
      return (e) => {
        const { hideReferrer: t, url: n } = e;
        return t ? a({ src: n }) : o({ src: n });
      };
    })(),
    dr = (({ window: e, createNamespacedStorage: t }) => {
      const n = t("validation.");
      return () => {
        const t = ye.parse(e.location.search).adb_validation_sessionid;
        if (!t) return "";
        const r = ((e) => {
            let t = e.persistent.getItem(cn);
            return (t || ((t = Re()), e.persistent.setItem(cn, t)), t);
          })(n),
          o = t + "|" + r;
        return "&" + ye.stringify({ adobeAepValidationToken: o });
      };
    })({ window: window, createNamespacedStorage: tr }),
    lr = (({ userAgent: e }) =>
      ee(() =>
        ((e, t) => {
          const n = Object.keys(e);
          for (let r = 0; r < n.length; r += 1) {
            const o = n[r];
            if (e[o].test(t)) return o;
          }
          return Z;
        })(
          {
            [X]: /Edge\/([0-9\._]+)/,
            [W]: /Edg\/([0-9\.]+)/,
            [Q]: /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
            [Y]: /Firefox\/([0-9\.]+)(?:\s|$)/,
            [K]: /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/,
            [$]: /Version\/([0-9\._]+).*Safari/,
          },
          e,
        ),
      ))({ userAgent: window.navigator.userAgent }),
    ur = ({
      instanceName: e,
      logController: {
        setDebugEnabled: t,
        logger: n,
        createComponentLogger: r,
      },
      components: i,
    }) => {
      const a = Nt(),
        s = Tt(a),
        l = i.concat(Object.values(er)),
        u = d({ logger: n, cookieJar: o }),
        p = Kt({ errorPrefix: "[" + e + "]", logger: n }),
        g = Gt({
          logger: n,
          configureCommand: (i) => {
            const d = Wt({
                options: i,
                componentCreators: l,
                coreConfigValidators: ir,
                createConfig: Yt,
                logger: n,
                setDebugEnabled: t,
              }),
              { orgId: p, targetMigrationEnabled: g } = d,
              m = ln({ orgId: p, targetMigrationEnabled: g }),
              f = (({
                cookieJar: e,
                shouldTransferCookie: t,
                apexDomain: n,
                dateProvider: r,
              }) => ({
                cookiesToPayload(r, o) {
                  const i = "" !== n && o.endsWith(n),
                    a = { domain: n, cookiesEnabled: !0 };
                  if (!i) {
                    const n = e.get(),
                      r = Object.keys(n)
                        .filter(t)
                        .map((e) => ({ key: e, value: n[e] }));
                    r.length && (a.entries = r);
                  }
                  r.mergeState(a);
                },
                responseToCookies(t) {
                  t.getPayloadsByType("state:store").forEach((t) => {
                    const o = { domain: n },
                      i =
                        t.attrs &&
                        t.attrs.SameSite &&
                        t.attrs.SameSite.toLowerCase();
                    (void 0 !== t.maxAge &&
                      (o.expires = new Date(r().getTime() + 1e3 * t.maxAge)),
                      void 0 !== i && (o.sameSite = i),
                      "none" === i && (o.secure = !0),
                      e.set(t.key, t.value, o));
                  });
                },
              }))({
                cookieJar: u,
                shouldTransferCookie: m,
                apexDomain: ar,
                dateProvider: () => new Date(),
              }),
              h = v(or.sendBeacon)
                ? (
                    ({ sendBeacon: e, sendFetchRequest: t, logger: n }) =>
                    (r, o) => {
                      const i = new Blob([o], {
                        type: "text/plain; charset=UTF-8",
                      });
                      return e(r, i)
                        ? Promise.resolve({
                            statusCode: 204,
                            getHeader: () => null,
                            body: "",
                          })
                        : (n.info(
                            "Unable to use `sendBeacon`; falling back to `fetch`.",
                          ),
                          t(r, o));
                    }
                  )({
                    sendBeacon: or.sendBeacon.bind(or),
                    sendFetchRequest: sr,
                    logger: n,
                  })
                : sr,
              y = (
                ({
                  logger: e,
                  sendFetchRequest: t,
                  sendBeaconRequest: n,
                  isRequestRetryable: r,
                  getRequestRetryDelay: o,
                }) =>
                ({ requestId: i, url: a, payload: s, useSendBeacon: c }) => {
                  const d = JSON.stringify(s),
                    l = JSON.parse(d);
                  e.logOnBeforeNetworkRequest({
                    url: a,
                    requestId: i,
                    payload: l,
                  });
                  const u = (s = 0) =>
                    (c ? n : t)(a, d).then((t) => {
                      if (r({ response: t, retriesAttempted: s })) {
                        const e = o({ response: t, retriesAttempted: s });
                        return new Promise((t) => {
                          setTimeout(() => {
                            t(u(s + 1));
                          }, e);
                        });
                      }
                      let n;
                      try {
                        n = JSON.parse(t.body);
                      } catch {}
                      return (
                        e.logOnNetworkResponse({
                          requestId: i,
                          url: a,
                          payload: l,
                          ...t,
                          parsedBody: n,
                          retriesAttempted: s,
                        }),
                        {
                          statusCode: t.statusCode,
                          body: t.body,
                          parsedBody: n,
                          getHeader: t.getHeader,
                        }
                      );
                    });
                  return u().catch((t) => {
                    throw (
                      e.logOnNetworkError({
                        requestId: i,
                        url: a,
                        payload: l,
                        error: t,
                      }),
                      be({ error: t, message: "Network request failed." })
                    );
                  });
                }
              )({
                logger: n,
                sendFetchRequest: sr,
                sendBeaconRequest: h,
                isRequestRetryable: hn,
                getRequestRetryDelay: yn,
              }),
              w = (
                ({ logger: e }) =>
                (t) => {
                  const { statusCode: n, body: r, parsedBody: o } = t;
                  if (
                    n < 200 ||
                    n >= 300 ||
                    (!o && 204 !== n) ||
                    (o && !Array.isArray(o.handle))
                  ) {
                    const e = o ? JSON.stringify(o, null, 2) : r;
                    throw new Error(
                      gn +
                        " status code " +
                        n +
                        " and " +
                        (e ? "response body:\n" + e : "no response body."),
                    );
                  }
                  if (o) {
                    const { warnings: t = [], errors: n = [] } = o;
                    (t.forEach((t) => {
                      e.warn(gn + " warning:", t);
                    }),
                      n.forEach((t) => {
                        e.error(gn + " non-fatal error:", t);
                      }));
                  }
                }
              )({ logger: n }),
              I = (
                ({ logger: e }) =>
                (t) => {
                  if (t) {
                    const n = t.split(";");
                    if (n.length >= 2 && n[1].length > 0)
                      try {
                        const e = parseInt(n[1], 10);
                        if (!Number.isNaN(e)) return { regionId: e };
                      } catch {}
                    e.warn('Invalid adobe edge: "' + t + '"');
                  }
                  return {};
                }
              )({ logger: n }),
              b = (
                ({ extractEdgeInfo: e }) =>
                ({ content: t = {}, getHeader: n }) => {
                  const {
                    handle: r = [],
                    errors: o = [],
                    warnings: i = [],
                  } = t;
                  return {
                    getPayloadsByType: (e) =>
                      r.filter((t) => t.type === e).flatMap((e) => e.payload),
                    getErrors: () => o,
                    getWarnings: () => i,
                    getEdge: () => e(n("x-adobe-edge")),
                    toJSON: () => t,
                  };
                }
              )({ extractEdgeInfo: I }),
              E = mn({ orgId: p, cookieJar: o }),
              C = (({
                config: e,
                lifecycle: t,
                cookieTransfer: n,
                sendNetworkRequest: r,
                createResponse: o,
                processWarningsAndErrors: i,
                getLocationHint: a,
                getAssuranceValidationTokenParams: s,
              }) => {
                const { edgeDomain: d, edgeBasePath: l, datastreamId: u } = e;
                let p = !1;
                const g = (e, t) => {
                  const n = a(),
                    r = n
                      ? l + "/" + n + t.getEdgeSubPath()
                      : "" + l + t.getEdgeSubPath(),
                    o = t.getDatastreamIdOverride() || u;
                  return (
                    o !== u &&
                      t
                        .getPayload()
                        .mergeMeta({
                          sdkConfig: { datastream: { original: u } },
                        }),
                    "https://" +
                      e +
                      "/" +
                      r +
                      "/v1/" +
                      t.getAction() +
                      "?configId=" +
                      o +
                      "&requestId=" +
                      t.getId() +
                      s()
                  );
                };
                return ({
                  request: e,
                  runOnResponseCallbacks: a = le,
                  runOnRequestFailureCallbacks: s = le,
                }) => {
                  const l = c();
                  (l.add(t.onResponse), l.add(a));
                  const u = c();
                  return (
                    u.add(t.onRequestFailure),
                    u.add(s),
                    t
                      .onBeforeRequest({
                        request: e,
                        onResponse: l.add,
                        onRequestFailure: u.add,
                      })
                      .then(() => {
                        const t =
                            p || !e.getUseIdThirdPartyDomain()
                              ? d
                              : "adobedc.demdex.net",
                          o = g(t, e),
                          i = e.getPayload();
                        return (
                          n.cookiesToPayload(i, t),
                          r({
                            requestId: e.getId(),
                            url: o,
                            payload: i,
                            useSendBeacon: e.getUseSendBeacon(),
                          })
                        );
                      })
                      .then((e) => (i(e), e))
                      .catch((t) => {
                        if (
                          ((e, t) =>
                            t.getUseIdThirdPartyDomain() &&
                            ((e) =>
                              "TypeError" === e.name ||
                              "NetworkError" === e.name ||
                              0 === e.status)(e))(t, e)
                        ) {
                          ((p = !0), e.setUseIdThirdPartyDomain(!1));
                          const t = g(d, e),
                            o = e.getPayload();
                          return (
                            n.cookiesToPayload(o, d),
                            r({
                              requestId: e.getId(),
                              url: t,
                              payload: o,
                              useSendBeacon: e.getUseSendBeacon(),
                            })
                          );
                        }
                        return pn(u)(t);
                      })
                      .then(({ parsedBody: e, getHeader: t }) => {
                        const r = o({ content: e, getHeader: t });
                        return (
                          n.responseToCookies(r),
                          l.call({ response: r }).then(un)
                        );
                      })
                  );
                };
              })({
                config: d,
                lifecycle: s,
                cookieTransfer: f,
                sendNetworkRequest: y,
                createResponse: b,
                processWarningsAndErrors: w,
                getLocationHint: E,
                getAssuranceValidationTokenParams: dr,
              }),
              k = (
                ({
                  cookieTransfer: e,
                  lifecycle: t,
                  createResponse: n,
                  processWarningsAndErrors: r,
                }) =>
                ({
                  request: o,
                  responseHeaders: i,
                  responseBody: a,
                  runOnResponseCallbacks: s = le,
                  runOnRequestFailureCallbacks: d = le,
                }) => {
                  const l = c();
                  (l.add(t.onResponse), l.add(s));
                  const u = c();
                  (u.add(t.onRequestFailure), u.add(d));
                  const p = (e) => i[e];
                  return t
                    .onBeforeRequest({
                      request: o,
                      onResponse: l.add,
                      onRequestFailure: u.add,
                    })
                    .then(() =>
                      r({
                        statusCode: 200,
                        getHeader: p,
                        body: JSON.stringify(a),
                        parsedBody: a,
                      }),
                    )
                    .catch(pn(u))
                    .then(() => {
                      const t = n({ content: a, getHeader: p });
                      return (
                        e.responseToCookies(t),
                        l.call({ response: t }).then(un)
                      );
                    });
                }
              )({
                lifecycle: s,
                cookieTransfer: f,
                createResponse: b,
                processWarningsAndErrors: w,
              }),
              S = (({ generalConsentState: e, logger: t }) => {
                const n = (n, r) => {
                  switch (n[qt]) {
                    case Mt:
                      e.in(r);
                      break;
                    case At:
                      e.out(r);
                      break;
                    case xt:
                      e.pending(r);
                      break;
                    default:
                      t.warn("Unknown consent value: " + n[qt]);
                  }
                };
                return {
                  initializeConsent(e, t) {
                    t[qt] ? n(t, jt) : n(e, Ut);
                  },
                  setConsent(e) {
                    n(e, _t);
                  },
                  suspend() {
                    e.pending();
                  },
                  awaitConsent: () => e.awaitConsent(),
                  withConsent: () => e.withConsent(),
                  current: () => e.current(),
                };
              })({ generalConsentState: Bt({ logger: n }), logger: n }),
              P = (({
                config: e,
                logger: t,
                lifecycle: n,
                consent: r,
                createEvent: o,
                createDataCollectionRequestPayload: i,
                createDataCollectionRequest: a,
                sendEdgeNetworkRequest: s,
                applyResponse: d,
              }) => {
                const { onBeforeEventSend: l, edgeConfigOverrides: u } = e;
                return {
                  createEvent: o,
                  sendEvent(e, o = {}) {
                    const { edgeConfigOverrides: d, ...p } = o,
                      g = sn({
                        payload: i(),
                        localConfigOverrides: d,
                        globalConfigOverrides: u,
                      }),
                      m = a(g),
                      f = c(),
                      h = c();
                    return n
                      .onBeforeEvent({
                        ...p,
                        event: e,
                        onResponse: f.add,
                        onRequestFailure: h.add,
                      })
                      .then(() => (g.payload.addEvent(e), r.awaitConsent()))
                      .then(() => {
                        try {
                          e.finalize(l);
                        } catch (e) {
                          const t = () => {
                            throw e;
                          };
                          return (
                            h.add(n.onRequestFailure),
                            h.call({ error: e }).then(t, t)
                          );
                        }
                        if (!e.shouldSend()) {
                          (h.add(n.onRequestFailure), t.info(dn));
                          const e = new Error(dn);
                          return h.call({ error: e }).then(() => {});
                        }
                        return s({
                          request: m,
                          runOnResponseCallbacks: f.call,
                          runOnRequestFailureCallbacks: h.call,
                        });
                      });
                  },
                  applyResponse(e, t = {}) {
                    const {
                        renderDecisions: r = !1,
                        decisionContext: o = {},
                        responseHeaders: s = {},
                        responseBody: l = { handle: [] },
                        personalization: u,
                      } = t,
                      p = i(),
                      g = a({ payload: p }),
                      m = c();
                    return n
                      .onBeforeEvent({
                        event: e,
                        renderDecisions: r,
                        decisionContext: o,
                        decisionScopes: [Zt],
                        personalization: u,
                        onResponse: m.add,
                        onRequestFailure: le,
                      })
                      .then(
                        () => (
                          p.addEvent(e),
                          d({
                            request: g,
                            responseHeaders: s,
                            responseBody: l,
                            runOnResponseCallbacks: m.call,
                          })
                        ),
                      );
                  },
                };
              })({
                config: d,
                logger: n,
                lifecycle: s,
                consent: S,
                createEvent: Ht,
                createDataCollectionRequestPayload: an,
                createDataCollectionRequest: nn,
                sendEdgeNetworkRequest: C,
                applyResponse: k,
              });
            return (({
              componentCreators: e,
              lifecycle: t,
              componentRegistry: n,
              getImmediatelyAvailableTools: r,
            }) => (
              e.forEach((e) => {
                const { namespace: t } = e,
                  o = r(t);
                let i;
                try {
                  i = e(o);
                } catch (e) {
                  throw be({
                    error: e,
                    message:
                      "[" +
                      t +
                      "] An error occurred during component creation.",
                  });
                }
                n.register(t, i);
              }),
              t.onComponentsRegistered({ lifecycle: t }).then(() => n)
            ))({
              componentCreators: l,
              lifecycle: s,
              componentRegistry: a,
              getImmediatelyAvailableTools(t) {
                const n = r(t);
                return {
                  config: d,
                  componentRegistry: a,
                  consent: S,
                  eventManager: P,
                  fireReferrerHideableImage: cr,
                  logger: n,
                  lifecycle: s,
                  sendEdgeNetworkRequest: C,
                  handleError: Kt({
                    errorPrefix: "[" + e + "] [" + t + "]",
                    logger: n,
                  }),
                  createNamespacedStorage: tr,
                  apexDomain: ar,
                  getBrowser: lr,
                };
              },
            });
          },
          setDebugCommand: (e) => {
            t(e.enabled, { fromConfig: !1 });
          },
          handleError: p,
          validateCommandOptions: Xt,
        });
      return g;
    };
  var pr = ({ eventManager: e, lifecycle: t, handleError: n }) => {
    const r = (
      ({ eventManager: e, lifecycle: t, handleError: n }) =>
      (r) => {
        if (r.s_fe) return Promise.resolve();
        const o =
            "composedPath" in r && r.composedPath().length > 0
              ? r.composedPath()[0]
              : r.target,
          i = e.createEvent();
        return (
          i.documentMayUnload(),
          t
            .onClick({ event: i, clickedElement: o })
            .then(() => (i.isEmpty() ? Promise.resolve() : e.sendEvent(i)))
            .then(le)
            .catch((e) => {
              n(e, "click collection");
            })
        );
      }
    )({ eventManager: e, lifecycle: t, handleError: n });
    document.addEventListener("click", r, !0);
  };
  const gr =
      "\\.(exe|zip|wav|mp3|mov|mpg|avi|wmv|pdf|doc|docx|xls|xlsx|ppt|pptx)$",
    mr = Et().regexp().default(gr),
    fr = bt({
      clickCollectionEnabled: ht().default(!0),
      clickCollection: bt({
        internalLinkEnabled: ht().default(!0),
        externalLinkEnabled: ht().default(!0),
        downloadLinkEnabled: ht().default(!0),
        sessionStorageEnabled: ht().default(!1),
        eventGroupingEnabled: ht().default(!1),
        filterClickProperties: yt(),
      }).default({
        internalLinkEnabled: !0,
        externalLinkEnabled: !0,
        downloadLinkEnabled: !0,
        sessionStorageEnabled: !1,
        eventGroupingEnabled: !1,
      }),
      downloadLinkQualifier: mr,
      onBeforeLinkClickSend: yt().deprecated(
        'The field "onBeforeLinkClickSend" has been deprecated. Use "clickCollection.filterClickDetails" instead.',
      ),
    });
  var hr = (e = document) => null !== e.getElementById("cppXYctnr"),
    yr = (e) => {
      let t = e;
      /^https?:\/\//i.test(t) || (t = window.location.protocol + "//" + e);
      return new URL(t).hostname;
    };
  var vr = ({
    config: e,
    logger: t,
    getClickedElementProperties: n,
    clickActivityStorage: r,
  }) => {
    const { clickCollectionEnabled: o, clickCollection: i } = e;
    return o
      ? ({ event: o, clickedElement: a }) => {
          const s = n({
              clickActivityStorage: r,
              clickedElement: a,
              config: e,
              logger: t,
            }),
            c = s.linkType;
          var d, l;
          hr() ||
            (s.isValidLink() &&
            ((e, t) =>
              t &&
              (("download" === t && !e.downloadLinkEnabled) ||
                ("exit" === t && !e.externalLinkEnabled) ||
                ("other" === t && !e.internalLinkEnabled)))(i, c)
              ? t.info(
                  "Cancelling link click event due to clickCollection." +
                    c +
                    "LinkEnabled = false.",
                )
              : s.isInternalLink() &&
                  i.eventGroupingEnabled &&
                  (!e.onBeforeLinkClickSend || i.filterClickDetails) &&
                  ((d = window.location.hostname),
                  (l = s.linkUrl),
                  yr(d) === yr(l))
                ? r.save(s.properties)
                : s.isValidLink()
                  ? (o.mergeXdm(s.xdm),
                    o.mergeData(s.data),
                    r.save({ pageName: s.pageName, pageIDType: s.pageIDType }))
                  : s.isValidActivityMapData() && r.save(s.properties));
        }
      : () => {};
  };
  var wr = ({ properties: e, logger: t } = {}) => {
    let n = e || {};
    return {
      get pageName() {
        return n.pageName;
      },
      set pageName(e) {
        n.pageName = e;
      },
      get linkName() {
        return n.linkName;
      },
      set linkName(e) {
        n.linkName = e;
      },
      get linkRegion() {
        return n.linkRegion;
      },
      set linkRegion(e) {
        n.linkRegion = e;
      },
      get linkType() {
        return n.linkType;
      },
      set linkType(e) {
        n.linkType = e;
      },
      get linkUrl() {
        return n.linkUrl;
      },
      set linkUrl(e) {
        n.linkUrl = e;
      },
      get pageIDType() {
        return n.pageIDType;
      },
      set pageIDType(e) {
        n.pageIDType = e;
      },
      get clickedElement() {
        return n.clickedElement;
      },
      set clickedElement(e) {
        n.clickedElement = e;
      },
      get properties() {
        return {
          pageName: n.pageName,
          linkName: n.linkName,
          linkRegion: n.linkRegion,
          linkType: n.linkType,
          linkUrl: n.linkUrl,
          pageIDType: n.pageIDType,
        };
      },
      isValidLink: () =>
        !!(n.linkUrl && n.linkType && n.linkName && n.linkRegion),
      isInternalLink() {
        return this.isValidLink() && "other" === n.linkType;
      },
      isValidActivityMapData: () =>
        !!n.pageName &&
        !!n.linkName &&
        !!n.linkRegion &&
        void 0 !== n.pageIDType,
      get xdm() {
        return n.filteredXdm
          ? n.filteredXdm
          : ((e) => ({
              eventType: "web.webinteraction.linkClicks",
              web: {
                webInteraction: {
                  name: e.linkName,
                  region: e.linkRegion,
                  type: e.linkType,
                  URL: e.linkUrl,
                  linkClicks: { value: 1 },
                },
              },
            }))(this);
      },
      get data() {
        return n.filteredData
          ? n.filteredData
          : ((e) => ({
              __adobe: {
                analytics: {
                  contextData: {
                    a: {
                      activitymap: {
                        page: e.pageName,
                        link: e.linkName,
                        region: e.linkRegion,
                        pageIDType: e.pageIDType,
                      },
                    },
                  },
                },
              },
            }))(this);
      },
      applyPropertyFilter(e) {
        e &&
          !1 === e(n) &&
          (t &&
            t.info(
              "Clicked element properties were rejected by filter function: " +
                JSON.stringify(this.properties, null, 2),
            ),
          (n = {}));
      },
      applyOptionsFilter(e) {
        const r = this.options;
        if (r && r.clickedElement && (r.xdm || r.data)) {
          if (e && !1 === e(r))
            return (
              t &&
                t.info(
                  "Clicked element properties were rejected by filter function: " +
                    JSON.stringify(this.properties, null, 2),
                ),
              void (this.options = void 0)
            );
          ((this.options = r),
            (n.filteredXdm = r.xdm),
            (n.filteredData = r.data));
        }
      },
      get options() {
        const e = {};
        if (
          (this.isValidLink() && (e.xdm = this.xdm),
          this.isValidActivityMapData() && (e.data = this.data),
          this.clickedElement && (e.clickedElement = this.clickedElement),
          e.xdm || e.data)
        )
          return e;
      },
      set options(e) {
        ((n = {}),
          e &&
            ((e, t) => {
              const { xdm: n, data: r, clickedElement: o } = e;
              if (
                ((t.clickedElement = o), n && n.web && n.web.webInteraction)
              ) {
                const {
                  name: e,
                  region: r,
                  type: o,
                  URL: i,
                } = n.web.webInteraction;
                ((t.linkName = e),
                  (t.linkRegion = r),
                  (t.linkType = o),
                  (t.linkUrl = i));
              }
              if (r && r.__adobe && r.__adobe.analytics) {
                const { contextData: e } = r.__adobe.analytics;
                if (e && e.a && e.a.activitymap) {
                  const {
                    page: n,
                    link: r,
                    region: o,
                    pageIDType: i,
                  } = e.a.activitymap;
                  ((t.pageName = n || t.pageName),
                    (t.linkName = r || t.linkName),
                    (t.linkRegion = o || t.linkRegion),
                    void 0 !== i && (t.pageIDType = i));
                }
              }
            })(e, n));
      },
    };
  };
  const Ir = "clickData";
  var br = (e) => e && e.replace(/\s+/g, " ").trim();
  const Er = /^(SCRIPT|STYLE|LINK|CANVAS|NOSCRIPT|#COMMENT)$/i;
  const Cr = (e) => {
      let t = [],
        n = !1;
      if (((e) => !(e && e.nodeName && e.nodeName.match(Er)))(e)) {
        if ((t.push(e), e.childNodes)) {
          Array.prototype.slice.call(e.childNodes).forEach((e) => {
            const r = Cr(e);
            ((t = t.concat(r.supportedNodes)),
              (n = n || r.includesUnsupportedNodes));
          });
        }
      } else n = !0;
      return { supportedNodes: t, includesUnsupportedNodes: n };
    },
    kr = (e, t, n) => {
      let r;
      return (
        (n && n !== e.nodeName.toUpperCase()) || (r = e.getAttribute(t)),
        r
      );
    };
  const Sr = /^(HEADER|MAIN|FOOTER|NAV)$/i,
    Pr = (e) => {
      let t;
      return (
        "region" === e.role && de(e["aria-label"]) && (t = e["aria-label"]),
        t
      );
    },
    Dr = (e) => {
      let t;
      return (e && e.nodeName && e.nodeName.match(Sr) && (t = e.nodeName), t);
    };
  var Rr = (e) =>
      !(
        !e.href ||
        ("A" !== e.tagName && "AREA" !== e.tagName) ||
        (e.onclick &&
          e.protocol &&
          !(e.protocol.toLowerCase().indexOf("javascript") < 0))
      ),
    Tr = (e) => !!e && !!e.onclick,
    Or = (e) => {
      if ("INPUT" === e.tagName) {
        const t = e.getAttribute("type");
        if ("submit" === t) return !0;
        if ("image" === t && e.src) return !0;
      }
      return !1;
    },
    Nr = (e) => "BUTTON" === e.tagName && "submit" === e.type,
    Mr = (e) => {
      const t = e.indexOf("?"),
        n = e.indexOf("#");
      return t >= 0 && (t < n || n < 0)
        ? e.substring(0, t)
        : n >= 0
          ? e.substring(0, n)
          : e;
    };
  const Ar = (
    ({
      window: e,
      getLinkName: t,
      getLinkRegion: n,
      getAbsoluteUrlFromAnchorElement: r,
      findClickableElement: o,
      determineLinkType: i,
    }) =>
    ({ clickedElement: a, config: s, logger: c, clickActivityStorage: d }) => {
      const { onBeforeLinkClickSend: l, clickCollection: u } = s,
        { filterClickDetails: p } = u,
        g = wr({ logger: c });
      if (a) {
        const c = o(a);
        if (c) {
          ((g.clickedElement = a),
            (g.linkUrl = r(e, c)),
            (g.linkType = i(e, s, g.linkUrl, c)),
            (g.linkRegion = n(c)),
            (g.linkName = t(c)),
            (g.pageIDType = 0),
            (g.pageName = e.location.href));
          const o = d.load();
          (o && o.pageName && ((g.pageName = o.pageName), (g.pageIDType = 1)),
            p ? g.applyPropertyFilter(p) : l && g.applyOptionsFilter(l));
        }
      }
      return g;
    }
  )({
    window: window,
    getLinkName: (e) => {
      let t = br(e.innerText || e.textContent);
      const n = Cr(e);
      if (!t || n.includesUnsupportedNodes) {
        const e = ((e) => {
          const t = { texts: [] };
          return (
            e.supportedNodes.forEach((e) => {
              (e.getAttribute &&
                (t.alt || (t.alt = br(e.getAttribute("alt"))),
                t.title || (t.title = br(e.getAttribute("title"))),
                t.inputValue || (t.inputValue = br(kr(e, "value", "INPUT"))),
                t.imgSrc || (t.imgSrc = br(kr(e, "src", "IMG")))),
                e.nodeValue && t.texts.push(e.nodeValue));
            }),
            t
          );
        })(n);
        ((t = br(e.texts.join(""))),
          t || (t = e.alt || e.title || e.inputValue || e.imgSrc));
      }
      return t || "";
    },
    getLinkRegion: (e) => {
      let t,
        n = e.parentNode;
      for (; n; ) {
        if (((t = br(n.id || Pr(n) || Dr(n))), t)) return t;
        n = n.parentNode;
      }
      return "BODY";
    },
    getAbsoluteUrlFromAnchorElement: (e, t) => {
      const n = e.location.href;
      let r = t.href || "";
      "string" != typeof r && (r = "");
      try {
        return new URL(r, n).href;
      } catch {
        return n;
      }
    },
    findClickableElement: (e) => {
      let t = e;
      for (; t; ) {
        if (Rr(t) || Tr(t) || Or(t) || Nr(t)) return t;
        t = t.parentNode;
      }
      return null;
    },
    determineLinkType: (e, t, n, r) => {
      let o = "other";
      return (
        de(n) &&
          (((e, t, n) => {
            let r = !1;
            if (t)
              if (n && n.download) r = !0;
              else if (e) {
                const n = new RegExp(e),
                  o = Mr(t).toLowerCase();
                r = n.test(o);
              }
            return r;
          })(t.downloadLinkQualifier, n, r)
            ? (o = "download")
            : ((e, t) => {
                let n = !1;
                if (t && e.location.hostname) {
                  const r = e.location.hostname.toLowerCase();
                  n = Mr(t).toLowerCase().indexOf(r) < 0;
                }
                return n;
              })(e, n) && (o = "exit")),
        o
      );
    },
  });
  let xr;
  const qr = (e) => {
      if (!xr) {
        const t = oe(window)(e.orgId || ""),
          n = (() => {
            const e = {};
            return {
              getItem: (t) => e[t],
              setItem: (t, n) => {
                e[t] = n;
              },
              removeItem: (t) => {
                delete e[t];
              },
            };
          })(),
          r = e.clickCollection.sessionStorageEnabled ? t.session : n;
        xr = (({ storage: e }) => ({
          save: (t) => {
            const n = JSON.stringify(t);
            e.setItem(Ir, n);
          },
          load: () => {
            let t = null;
            const n = e.getItem(Ir);
            return (n && (t = JSON.parse(n)), t);
          },
          remove: () => {
            e.removeItem(Ir);
          },
        }))({ storage: r });
      }
    },
    Lr = ({ config: e, eventManager: t, handleError: n, logger: r }) => {
      ((e, t) => {
        const {
          clickCollectionEnabled: n,
          onBeforeLinkClickSend: r,
          downloadLinkQualifier: o,
        } = e;
        !1 === n &&
          (r &&
            t.warn(
              "The 'onBeforeLinkClickSend' configuration was provided but will be ignored because clickCollectionEnabled is false.",
            ),
          o &&
            o !== gr &&
            t.warn(
              "The 'downloadLinkQualifier' configuration was provided but will be ignored because clickCollectionEnabled is false.",
            ));
      })(e, r);
      const o = e.clickCollection;
      xr || qr(e);
      const i = vr({
          config: e,
          logger: r,
          clickActivityStorage: xr,
          getClickedElementProperties: Ar,
        }),
        a = (
          ({ clickActivityStorage: e }) =>
          (t) => {
            if (hr()) return;
            const n = e.load(),
              r = wr({ properties: n });
            if (r.isValidLink() || r.isValidActivityMapData()) {
              if (r.isValidLink()) {
                const e = r.xdm;
                (delete e.eventType, t.mergeXdm(e));
              }
              (r.isValidActivityMapData() && t.mergeData(r.data),
                e.save({ pageName: r.pageName, pageIDType: r.pageIDType }));
            }
          }
        )({ clickActivityStorage: xr }),
        s = (
          ({ clickActivityStorage: e }) =>
          (t) => {
            e.save({
              pageName: t.getContent().xdm.web.webPageDetails.name,
              pageIDType: 1,
            });
          }
        )({ clickActivityStorage: xr });
      return {
        lifecycle: {
          onComponentsRegistered(e) {
            const { lifecycle: r } = e;
            pr({ eventManager: t, lifecycle: r, handleError: n });
          },
          onClick({ event: e, clickedElement: t }) {
            i({ event: e, clickedElement: t });
          },
          onBeforeEvent({ event: e }) {
            ((e) => {
              const t = e.getContent();
              return (
                void 0 !== t.xdm &&
                void 0 !== t.xdm.web &&
                void 0 !== t.xdm.web.webPageDetails &&
                void 0 !== t.xdm.web.webPageDetails.name
              );
            })(e) && (o.eventGroupingEnabled && a(e), s(e, r, xr));
          },
        },
      };
    };
  ((Lr.namespace = "ActivityCollector"),
    (Lr.configValidators = fr),
    (Lr.buildOnInstanceConfiguredExtraParams = ({ config: e, logger: t }) => (
      xr || qr(e),
      {
        getLinkDetails: (n) =>
          Ar({
            clickActivityStorage: xr,
            clickedElement: n,
            config: e,
            logger: t,
          }).properties,
      }
    )));
  var Ur = ({
      fireReferrerHideableImage: e,
      logger: t,
      cookieJar: n,
      isPageSsl: r,
    }) => {
      const o = r ? { sameSite: "none", secure: !0 } : {};
      return (r) => (
        ((e) => {
          e.filter((e) => "cookie" === e.type).forEach((e) => {
            const { name: t, value: r, domain: i, ttlDays: a } = e.spec;
            n.set(t, r || "", { domain: i || "", expires: a || 10, ...o });
          });
        })(r),
        ((n) => {
          const r = n.filter((e) => "url" === e.type);
          return Promise.all(
            r.map((n) =>
              e(n.spec)
                .then(() => {
                  t.info(
                    ((e) => "URL destination succeeded: " + e.spec.url)(n),
                  );
                })
                .catch(() => {}),
            ),
          ).then(le);
        })(r)
      );
    },
    jr =
      ({ processDestinations: e }) =>
      ({ response: t }) =>
        (({ response: t }) => {
          const n = t.getPayloadsByType("activation:push");
          return e(n);
        })({ response: t }).then(() =>
          (({ response: e }) => ({
            destinations: e.getPayloadsByType("activation:pull"),
          }))({ response: t }),
        );
  const _r = ({ logger: e, fireReferrerHideableImage: t }) => {
    const n = o.withConverter({ write: (e) => encodeURIComponent(e) }),
      r = d({ logger: e, cookieJar: n }),
      i = Ur({
        fireReferrerHideableImage: t,
        logger: e,
        cookieJar: r,
        isPageSsl: "https:" === window.location.protocol,
      });
    return {
      lifecycle: { onResponse: jr({ processDestinations: i }) },
      commands: {},
    };
  };
  _r.namespace = "Audiences";
  var Fr = (e) => F(JSON.stringify(ve(e)));
  const Br = ({ standard: e, version: t }) => e + "." + t;
  var Vr = () => {
      const e = {},
        t = rn({
          content: e,
          addIdentity: (t, n) => {
            ((e.identityMap = e.identityMap || {}),
              (e.identityMap[t] = e.identityMap[t] || []),
              e.identityMap[t].push(n));
          },
          hasIdentity: (t) => void 0 !== (e.identityMap && e.identityMap[t]),
        });
      return (
        (t.setConsent = (t) => {
          e.consent = t;
        }),
        t
      );
    },
    Hr = ({ payload: e, datastreamIdOverride: t }) =>
      tn({
        payload: e,
        datastreamIdOverride: t,
        getAction: () => "privacy/set-consent",
        getUseSendBeacon: () => !1,
      }),
    zr = (e) =>
      e.split(";").reduce((e, t) => {
        const [n, r] = t.split("=");
        return ((e[n] = r), e);
      }, {}),
    Jr = bt({
      consent: ft(mt()).required().nonEmpty(),
      identityMap: kt,
      edgeConfigOverrides: St,
    })
      .noUnknownFields()
      .required(),
    Gr = bt({ defaultConsent: Ct(Mt, At, xt).default(Mt) });
  const Qr = ({
    config: e,
    consent: n,
    sendEdgeNetworkRequest: r,
    createNamespacedStorage: i,
  }) => {
    const { orgId: a, defaultConsent: s } = e,
      c = (({ parseConsentCookie: e, orgId: t, cookieJar: n }) => {
        const r = J(t, "consent");
        return {
          read() {
            const t = n.get(r);
            return t ? e(t) : {};
          },
          clear() {
            n.remove(r);
          },
        };
      })({ parseConsentCookie: zr, orgId: a, cookieJar: o }),
      d = (() => {
        let e = 0,
          t = Promise.resolve();
        return {
          addTask(n) {
            e += 1;
            const r = () =>
              n().finally(() => {
                e -= 1;
              });
            return ((t = t.then(r, r)), t);
          },
          get length() {
            return e;
          },
        };
      })(),
      l = (
        ({
          createConsentRequestPayload: e,
          createConsentRequest: n,
          sendEdgeNetworkRequest: r,
          edgeConfigOverrides: o,
        }) =>
        ({ consentOptions: i, identityMap: a, edgeConfigOverrides: s }) => {
          const c = sn({
            payload: e(),
            globalConfigOverrides: o,
            localConfigOverrides: s,
          });
          (c.payload.setConsent(i),
            t(a) &&
              Object.keys(a).forEach((e) => {
                a[e].forEach((t) => {
                  c.payload.addIdentity(e, t);
                });
              }));
          const d = n(c);
          return r({ request: d }).then(() => {});
        }
      )({
        createConsentRequestPayload: Vr,
        createConsentRequest: Hr,
        sendEdgeNetworkRequest: r,
        edgeConfigOverrides: e.edgeConfigOverrides,
      }),
      u = (({ storage: e }) => ({
        clear() {
          e.clear();
        },
        lookup(t) {
          const n = {},
            r = (e) => {
              const t = Br(e),
                { standard: r, version: o, ...i } = e;
              return (n[t] || (n[t] = Fr(i).toString()), n[t]);
            };
          return {
            isNew: () =>
              t.some((t) => {
                const n = Br(t),
                  o = e.getItem(n);
                return null === o || o !== r(t);
              }),
            save() {
              t.forEach((t) => {
                const n = Br(t);
                e.setItem(n, r(t));
              });
            },
          };
        },
      }))({ storage: i(z(a) + ".consentHashes.").persistent }),
      p = ne({ orgId: a });
    return (({
      storedConsent: e,
      taskQueue: t,
      defaultConsent: n,
      consent: r,
      sendSetConsentRequest: o,
      validateSetConsentOptions: i,
      consentHashStore: a,
      doesIdentityCookieExist: s,
    }) => {
      const c = { [qt]: n };
      let d = e.read();
      const l = s(),
        u = void 0 !== d[qt];
      ((l && u) || a.clear(),
        l || (e.clear(), (d = {})),
        r.initializeConsent(c, d));
      const p = () => {
        if (0 === t.length) {
          const t = e.read();
          void 0 !== t[qt] && r.setConsent(t);
        }
      };
      return {
        commands: {
          setConsent: {
            optionsValidator: i,
            run: ({ consent: e, identityMap: n, edgeConfigOverrides: i }) => {
              r.suspend();
              const s = a.lookup(e);
              return t
                .addTask(() =>
                  s.isNew()
                    ? o({
                        consentOptions: e,
                        identityMap: n,
                        edgeConfigOverrides: i,
                      })
                    : Promise.resolve(),
                )
                .then(() => s.save())
                .finally(p);
            },
          },
        },
        lifecycle: { onResponse: p, onRequestFailure: p },
      };
    })({
      storedConsent: c,
      taskQueue: d,
      defaultConsent: s,
      consent: n,
      sendSetConsentRequest: l,
      validateSetConsentOptions: Jr,
      consentHashStore: u,
      doesIdentityCookieExist: p,
    });
  };
  ((Qr.namespace = "Consent"), (Qr.configValidators = Gr));
  var Xr = () => ({ eventMergeId: Re() });
  const Wr = () =>
    (({ createEventMergeId: e }) => ({
      commands: { createEventMergeId: { run: e } },
    }))({ createEventMergeId: Xr });
  Wr.namespace = "EventMerge";
  var Yr = {
      PAUSE: "media.pauseStart",
      PLAY: "media.play",
      BUFFER_START: "media.bufferStart",
      AD_START: "media.adStart",
      Ad_BREAK_START: "media.adBreakStart",
      SESSION_END: "media.sessionEnd",
      SESSION_START: "media.sessionStart",
      SESSION_COMPLETE: "media.sessionComplete",
      PING: "media.ping",
      AD_BREAK_COMPLETE: "media.adBreakComplete",
      AD_COMPLETE: "media.adComplete",
      AD_SKIP: "media.adSkip",
      BITRATE_CHANGE: "media.bitrateChange",
      CHAPTER_COMPLETE: "media.chapterComplete",
      CHAPTER_SKIP: "media.chapterSkip",
      CHAPTER_START: "media.chapterStart",
      ERROR: "media.error",
      STATES_UPDATE: "media.statesUpdate",
    },
    Kr = ({
      config: e,
      eventManager: t,
      consent: n,
      sendEdgeNetworkRequest: r,
      setTimestamp: o,
    }) => ({
      createMediaEvent({ options: n }) {
        const r = t.createEvent(),
          { xdm: i } = n;
        if ((o(i), r.setUserXdm(i), i.eventType === Yr.AD_START)) {
          const { advertisingDetails: t } = n.xdm.mediaCollection;
          r.mergeXdm({
            mediaCollection: {
              advertisingDetails: {
                playerName: t.playerName || e.streamingMedia.playerName,
              },
            },
          });
        }
        return r;
      },
      createMediaSession(n) {
        const { playerName: r, channel: o, appVersion: i } = e.streamingMedia,
          a = t.createEvent(),
          { sessionDetails: s } = n.xdm.mediaCollection;
        return (
          a.setUserXdm(n.xdm),
          a.mergeXdm({
            eventType: Yr.SESSION_START,
            mediaCollection: {
              sessionDetails: {
                playerName: s.playerName || r,
                channel: s.channel || o,
                appVersion: s.appVersion || i,
              },
            },
          }),
          a
        );
      },
      augmentMediaEvent({
        event: e,
        playerId: t,
        getPlayerDetails: n,
        sessionID: r,
      }) {
        if (!t || !n) return e;
        const { playhead: o, qoeDataDetails: i } = n({ playerId: t });
        return (
          e.mergeXdm({
            mediaCollection: {
              playhead: Ee(o),
              qoeDataDetails: i,
              sessionID: r,
            },
          }),
          e
        );
      },
      trackMediaSession({ event: e, mediaOptions: n, edgeConfigOverrides: r }) {
        const o = { mediaOptions: n, edgeConfigOverrides: r };
        return t.sendEvent(e, o);
      },
      trackMediaEvent({ event: e, action: t }) {
        const o = an(),
          i = (({ mediaRequestPayload: e, action: t }) =>
            tn({
              payload: e,
              edgeSubPath: "/va",
              getAction: () => t,
              getUseSendBeacon: () => !1,
            }))({ mediaRequestPayload: o, action: t });
        return (
          o.addEvent(e),
          e.finalize(),
          n.awaitConsent().then(() => r({ request: i }).then(() => ({})))
        );
      },
    }),
    $r = "main",
    Zr = "completed",
    eo = () => {
      let e;
      return {
        getSession: (t) => e[t] || {},
        storeSession: ({ playerId: t, sessionDetails: n }) => {
          (void 0 === e && (e = {}), (e[t] = n));
        },
        stopPing: ({ playerId: t }) => {
          const n = e[t];
          n &&
            (clearTimeout(n.pingId), (n.pingId = null), (n.playbackState = Zr));
        },
        savePing: ({ playerId: t, pingId: n, playbackState: r }) => {
          e[t] &&
            (e[t].pingId && clearTimeout(e[t].pingId),
            (e[t].pingId = n),
            (e[t].playbackState = r));
        },
      };
    };
  var to = ({
      mediaEventManager: e,
      mediaSessionCacheManager: t,
      config: n,
    }) => {
      const r = (o) => {
        const i = e.createMediaEvent({ options: o }),
          { playerId: a, xdm: s } = o,
          { eventType: c } = s,
          d = c.split(".")[1],
          {
            getPlayerDetails: l,
            sessionPromise: u,
            playbackState: p,
          } = t.getSession(a);
        return u.then((o) =>
          o.sessionId
            ? (e.augmentMediaEvent({
                event: i,
                eventType: c,
                playerId: a,
                getPlayerDetails: l,
                sessionID: o.sessionId,
              }),
              e.trackMediaEvent({ event: i, action: d }).then(() => {
                if (a)
                  if (c === Yr.SESSION_COMPLETE || c === Yr.SESSION_END)
                    t.stopPing({ playerId: a });
                  else {
                    const e = ((e, t) =>
                      e === Yr.AD_START ||
                      e === Yr.Ad_BREAK_START ||
                      e === Yr.AD_SKIP ||
                      e === Yr.AD_COMPLETE
                        ? "ad"
                        : e === Yr.AD_BREAK_COMPLETE ||
                            e === Yr.CHAPTER_COMPLETE ||
                            e === Yr.CHAPTER_START ||
                            e === Yr.CHAPTER_SKIP ||
                            e === Yr.SESSION_START
                          ? "main"
                          : e === Yr.SESSION_END || e === Yr.SESSION_COMPLETE
                            ? "completed"
                            : t)(c, p);
                    if ("completed" === e) return;
                    const o =
                        "ad" === e
                          ? n.streamingMedia.adPingInterval
                          : n.streamingMedia.mainPingInterval,
                      i = setTimeout(() => {
                        r({ playerId: a, xdm: { eventType: Yr.PING } });
                      }, 1e3 * o);
                    t.savePing({ playerId: a, pingId: i, playbackState: e });
                  }
              }))
            : Promise.reject(
                new Error(
                  "Failed to trigger media event: " +
                    c +
                    ". Session ID is not available for playerId: " +
                    a +
                    ".",
                ),
              ),
        );
      };
      return (e) => r(e);
    },
    no =
      ({
        config: e,
        mediaEventManager: t,
        mediaSessionCacheManager: n,
        legacy: r = !1,
      }) =>
      (o) => {
        if (!e.streamingMedia)
          return Promise.reject(
            new Error("Streaming media is not configured."),
          );
        const { playerId: i, getPlayerDetails: a, edgeConfigOverrides: s } = o,
          c = t.createMediaSession(o);
        t.augmentMediaEvent({ event: c, playerId: i, getPlayerDetails: a });
        const d = t.trackMediaSession({
          event: c,
          mediaOptions: { playerId: i, getPlayerDetails: a, legacy: r },
          edgeConfigOverrides: s,
        });
        return (
          n.storeSession({
            playerId: i,
            sessionDetails: {
              sessionPromise: d,
              getPlayerDetails: a,
              playbackState: $r,
            },
          }),
          d
        );
      },
    ro = (e) => !ce(e) || !e.trim(),
    oo =
      ({ mediaSessionCacheManager: e, config: t, trackMediaEvent: n }) =>
      ({ response: r, playerId: o, getPlayerDetails: i }) => {
        const a = r.getPayloadsByType("media-analytics:new-session");
        if (w(a)) {
          const { sessionId: r } = a[0];
          if (ro(r)) return {};
          if (!o || !i) return { sessionId: r };
          const s = setTimeout(() => {
            n({ playerId: o, xdm: { eventType: Yr.PING } });
          }, 1e3 * t.streamingMedia.mainPingInterval);
          return (
            e.savePing({ playerId: o, pingId: s, playbackState: $r }),
            { sessionId: r }
          );
        }
        return {};
      };
  const io = { Video: "video", Audio: "audio" },
    ao = {
      VOD: "vod",
      Live: "live",
      Linear: "linear",
      Podcast: "podcast",
      Audiobook: "audiobook",
      AOD: "aod",
    },
    so = {
      FullScreen: "fullScreen",
      ClosedCaption: "closedCaptioning",
      Mute: "mute",
      PictureInPicture: "pictureInPicture",
      InFocus: "inFocus",
    },
    co = {
      AdBreakStart: "adBreakStart",
      AdBreakComplete: "adBreakComplete",
      AdStart: "adStart",
      AdComplete: "adComplete",
      AdSkip: "adSkip",
      ChapterStart: "chapterStart",
      ChapterComplete: "chapterComplete",
      ChapterSkip: "chapterSkip",
      SeekStart: "seekStart",
      SeekComplete: "seekComplete",
      BufferStart: "bufferStart",
      BufferComplete: "bufferComplete",
      BitrateChange: "bitrateChange",
      StateStart: "stateStart",
      StateEnd: "stateEnd",
    },
    lo = "sessionStart",
    uo = "sessionEnd",
    po = "sessionComplete",
    go = "play",
    mo = "pauseStart",
    fo = "error",
    ho = "statesUpdate",
    yo = {
      MediaResumed: "media.resumed",
      GranularAdTracking: "media.granularadtracking",
    },
    vo = {
      Show: "a.media.show",
      Season: "a.media.season",
      Episode: "a.media.episode",
      AssetId: "a.media.asset",
      Genre: "a.media.genre",
      FirstAirDate: "a.media.airDate",
      FirstDigitalDate: "a.media.digitalDate",
      Rating: "a.media.rating",
      Originator: "a.media.originator",
      Network: "a.media.network",
      ShowType: "a.media.type",
      AdLoad: "a.media.adLoad",
      MVPD: "a.media.pass.mvpd",
      Authorized: "a.media.pass.auth",
      DayPart: "a.media.dayPart",
      Feed: "a.media.feed",
      StreamFormat: "a.media.format",
    },
    wo = {
      Artist: "a.media.artist",
      Album: "a.media.album",
      Label: "a.media.label",
      Author: "a.media.author",
      Station: "a.media.station",
      Publisher: "a.media.publisher",
    },
    Io = {
      Advertiser: "a.media.ad.advertiser",
      CampaignId: "a.media.ad.campaign",
      CreativeId: "a.media.ad.creative",
      PlacementId: "a.media.ad.placement",
      SiteId: "a.media.ad.site",
      CreativeUrl: "a.media.ad.creativeURL",
    };
  var bo = ({ logger: e }) => ({
    createMediaObject: (t, n, r, o, i) => {
      const a = {
          friendlyName: t,
          name: n,
          length: r,
          streamType: i,
          contentType: o,
        },
        s = bt({
          friendlyName: Et().nonEmpty(),
          name: Et().nonEmpty(),
          length: wt().required(),
          streamType: Et().nonEmpty(),
          contentType: Et().nonEmpty(),
        });
      try {
        const e = s(a);
        return {
          sessionDetails: {
            name: e.name,
            friendlyName: e.friendlyName,
            length: Math.round(e.length),
            streamType: e.streamType,
            contentType: e.contentType,
          },
        };
      } catch (t) {
        return (
          e.warn("An error occurred while creating the Media Object.", t),
          {}
        );
      }
    },
    createAdBreakObject: (t, n, r) => {
      const o = { friendlyName: t, offset: n, index: r },
        i = bt({ friendlyName: Et().nonEmpty(), offset: wt(), index: wt() });
      try {
        const e = i(o);
        return {
          advertisingPodDetails: {
            friendlyName: e.friendlyName,
            offset: e.offset,
            index: e.index,
          },
        };
      } catch (t) {
        return (
          e.warn("An error occurred while creating the Ad Break Object.", t),
          {}
        );
      }
    },
    createAdObject: (t, n, r, o) => {
      const i = { friendlyName: t, name: n, podPosition: r, length: o },
        a = bt({
          friendlyName: Et().nonEmpty(),
          name: Et().nonEmpty(),
          podPosition: wt(),
          length: wt(),
        });
      try {
        const e = a(i);
        return {
          advertisingDetails: {
            friendlyName: e.friendlyName,
            name: e.name,
            podPosition: e.podPosition,
            length: e.length,
          },
        };
      } catch (t) {
        return (
          e.warn("An error occurred while creating the Advertising Object.", t),
          {}
        );
      }
    },
    createChapterObject: (t, n, r, o) => {
      const i = { friendlyName: t, offset: n, length: r, index: o },
        a = bt({
          friendlyName: Et().nonEmpty(),
          offset: wt(),
          length: wt(),
          index: wt(),
        });
      try {
        const e = a(i);
        return {
          chapterDetails: {
            friendlyName: e.friendlyName,
            offset: e.offset,
            index: e.index,
            length: e.length,
          },
        };
      } catch (t) {
        return (
          e.warn("An error occurred while creating the Chapter Object.", t),
          {}
        );
      }
    },
    createStateObject: (t) => {
      const n = Et().matches(
        /^[a-zA-Z0-9_]{1,64}$/,
        "This is not a valid state name.",
      );
      try {
        return { name: n(t) };
      } catch (t) {
        return (
          e.warn("An error occurred while creating the State Object.", t),
          {}
        );
      }
    },
    createQoEObject: (t, n, r, o) => {
      const i = { bitrate: t, droppedFrames: n, fps: r, startupTime: o },
        a = bt({
          bitrate: wt(),
          droppedFrames: wt(),
          fps: wt(),
          startupTime: wt(),
        });
      try {
        const e = a(i);
        return {
          bitrate: e.bitrate,
          droppedFrames: e.droppedFrames,
          framesPerSecond: e.fps,
          timeToStart: e.startupTime,
        };
      } catch (t) {
        return (
          e.warn("An error occurred while creating the QOE Object.", t),
          {}
        );
      }
    },
  });
  const Eo = {
      "a.media.show": "show",
      "a.media.season": "season",
      "a.media.episode": "episode",
      "a.media.asset": "assetID",
      "a.media.genre": "genre",
      "a.media.airDate": "firstAirDate",
      "a.media.digitalDate": "firstDigitalDate",
      "a.media.rating": "rating",
      "a.media.originator": "originator",
      "a.media.network": "network",
      "a.media.type": "showType",
      "a.media.adLoad": "adLoad",
      "a.media.pass.mvpd": "mvpd",
      "a.media.pass.auth": "authorized",
      "a.media.dayPart": "dayPart",
      "a.media.feed": "feed",
      "a.media.format": "streamFormat",
      "a.media.artist": "artist",
      "a.media.album": "album",
      "a.media.label": "label",
      "a.media.author": "author",
      "a.media.station": "station",
      "a.media.publisher": "publisher",
      "media.resumed": "hasResume",
    },
    Co = {
      "a.media.ad.advertiser": "advertiser",
      "a.media.ad.campaign": "campaignID",
      "a.media.ad.creative": "creativeID",
      "a.media.ad.placement": "placementID",
      "a.media.ad.site": "siteID",
      "a.media.ad.creativeURL": "creativeURL",
    };
  var ko = ({
    logger: t,
    trackMediaSession: n,
    trackMediaEvent: r,
    uuid: o,
  }) => {
    let i = null;
    const a = ({ eventType: e, mediaDetails: t = {}, contextData: n = [] }) => {
      const r = (({ eventType: e }) =>
        e === co.BufferComplete || e === co.SeekComplete
          ? go
          : e === co.StateStart || e === co.StateEnd
            ? ho
            : e === co.SeekStart
              ? mo
              : e)({ eventType: e });
      if (e === co.StateStart) {
        return {
          eventType: "media." + r,
          mediaCollection: { statesStart: [t] },
        };
      }
      if (e === co.StateEnd) {
        return { eventType: "media." + r, mediaCollection: { statesEnd: [t] } };
      }
      const o = { eventType: "media." + r, mediaCollection: { ...t } },
        i = [];
      return (
        Object.keys(n).forEach((e) => {
          Eo[e]
            ? (o.mediaCollection.sessionDetails[Eo[e]] = n[e])
            : Co[e]
              ? (o.mediaCollection.advertisingDetails[Co[e]] = n[e])
              : i.push({ name: e, value: n[e] });
        }),
        w(i) && (o.mediaCollection.customMetadata = i),
        o
      );
    };
    return {
      trackSessionStart: (r, s = {}) => {
        if (e(r) || j(r)) return (t.warn("Invalid media object"), {});
        null === i &&
          (t.warn("The Media Session was completed. Restarting a new session."),
          (i = { qoe: null, lastPlayhead: 0, playerId: o() }));
        const c = a({ eventType: lo, mediaDetails: r, contextData: s });
        return n({
          playerId: i.playerId,
          getPlayerDetails: () => ({
            playhead: i.lastPlayhead,
            qoeDataDetails: i.qoe,
          }),
          xdm: c,
        });
      },
      trackPlay: () => {
        if (null === i) return (t.warn("The Media Session was completed."), {});
        const e = a({ eventType: go });
        return r({ playerId: i.playerId, xdm: e });
      },
      trackPause: () => {
        if (null === i) return (t.warn("The Media Session was completed."), {});
        const e = a({ eventType: mo });
        return r({ playerId: i.playerId, xdm: e });
      },
      trackSessionEnd: () => {
        if (null === i) return (t.warn("The Media Session was completed."), {});
        const e = a({ eventType: uo });
        return r({ playerId: i.playerId, xdm: e });
      },
      trackComplete: () => {
        if (null === i) return (t.warn("The Media Session was completed."), {});
        const e = a({ eventType: po });
        return r({ playerId: i.playerId, xdm: e });
      },
      trackError: (e) => {
        if ((t.warn("trackError(" + e + ")"), null === i))
          return (t.warn("The Media Session was completed."), {});
        const n = a({
          eventType: fo,
          mediaDetails: { errorDetails: { name: e, source: "player" } },
        });
        return r({ playerId: i.playerId, xdm: n });
      },
      trackEvent: (e, n, o) => {
        if (j(n)) return (t.warn("Invalid media object."), {});
        if (null === i) return (t.warn("The Media Session was completed."), {});
        if (!Object.values(co).includes(e))
          return (t.warn("Invalid event type"), {});
        const s = a({ eventType: e, mediaDetails: n, contextData: o });
        return r({ playerId: i.playerId, xdm: s });
      },
      updatePlayhead: (e) => {
        null !== i
          ? ae(e) && (i.lastPlayhead = parseInt(e, 10))
          : t.warn("The Media Session was completed.");
      },
      updateQoEObject: (e) => {
        null !== i
          ? e && (i.qoe = e)
          : t.warn("The Media Session was completed.");
      },
      destroy: () => {
        (t.warn("Destroy called, destroying the tracker."), (i = null));
      },
    };
  };
  const So = ({
    eventManager: e,
    sendEdgeNetworkRequest: t,
    config: n,
    logger: r,
    consent: o,
  }) => {
    const i = eo(),
      a = Kr({
        sendEdgeNetworkRequest: t,
        config: n,
        consent: o,
        eventManager: e,
        setTimestamp: wn(() => new Date()),
      }),
      s = to({ mediaSessionCacheManager: i, mediaEventManager: a, config: n }),
      c = no({
        config: n,
        mediaEventManager: a,
        mediaSessionCacheManager: i,
        legacy: !0,
      });
    return (({
      trackMediaEvent: e,
      trackMediaSession: t,
      mediaResponseHandler: n,
      logger: r,
      createMediaHelper: o,
      createGetInstance: i,
      config: a,
    }) => ({
      lifecycle: {
        onBeforeEvent({ mediaOptions: e, onResponse: t = le }) {
          if (!e) return;
          const { legacy: r, playerId: o, getPlayerDetails: i } = e;
          r &&
            t(({ response: e }) =>
              n({ playerId: o, getPlayerDetails: i, response: e }),
            );
        },
      },
      commands: {
        getMediaAnalyticsTracker: {
          run: () => {
            if (!a.streamingMedia)
              return Promise.reject(
                new Error("Streaming media is not configured."),
              );
            r.info("Streaming media is configured in legacy mode.");
            const n = o({ logger: r });
            return Promise.resolve({
              getInstance: () =>
                i({
                  logger: r,
                  trackMediaEvent: e,
                  trackMediaSession: t,
                  uuid: Re,
                }),
              Event: co,
              MediaType: io,
              PlayerState: so,
              StreamType: ao,
              MediaObjectKey: yo,
              VideoMetadataKeys: vo,
              AudioMetadataKeys: wo,
              AdMetadataKeys: Io,
              ...n,
            });
          },
        },
      },
    }))({
      mediaResponseHandler: oo({
        mediaSessionCacheManager: i,
        config: n,
        trackMediaEvent: s,
      }),
      trackMediaSession: c,
      trackMediaEvent: s,
      createMediaHelper: bo,
      createGetInstance: ko,
      logger: r,
      config: n,
    });
  };
  So.namespace = "Legacy Media Analytics";
  const Po = "web",
    Do = "webapp",
    Ro = "://",
    To = /^(\w+):\/\/([^/#]+)(\/[^#]*)?(#.*)?$/,
    Oo = /^(?:.*@)?(?:[a-z\d\u00a1-\uffff.-]+|\[[a-f\d:]+])(?::\d+)?$/,
    No = /^\/(?:[/\w\u00a1-\uffff-.~]|%[a-fA-F\d]{2})*$/,
    Mo = /^#(?:[/\w\u00a1-\uffff-.~]|%[a-fA-F\d]{2})+$/,
    Ao = (e = "/") => {
      let t = e.length;
      for (; t > 0 && -1 !== "/".indexOf(e.charAt(t - 1)); ) t -= 1;
      return e.substring(0, t) || "/";
    },
    xo = (e) =>
      "" +
      e.surfaceType +
      Ro +
      e.authority +
      (e.path || "") +
      (e.fragment || ""),
    qo = (e) => {
      const t = e(),
        n = t.host.toLowerCase(),
        r = t.pathname;
      return Po + Ro + n + Ao(r);
    },
    Lo = (e, t, n) => {
      const r = (e) => (n.warn(e), null);
      if (!de(e)) return r("Invalid surface: " + e);
      const o = ((e, t) => (e.startsWith("#") ? qo(t) + e : e))(e, t),
        i = ((e) => {
          const t = e.match(To);
          return t
            ? {
                surfaceType: ((o = t[1]), de(o) ? o.toLowerCase() : ""),
                authority: ((r = t[2]), de(r) ? r.toLowerCase() : ""),
                path: ((n = t[3]), de(n) ? Ao(n) : "/"),
                fragment: t[4],
              }
            : null;
          var n, r, o;
        })(o);
      return null === i
        ? r("Invalid surface: " + e)
        : [Po, Do].includes(i.surfaceType)
          ? i.authority && Oo.test(i.authority)
            ? i.path && !No.test(i.path)
              ? r("Invalid path " + i.path + " in surface: " + e)
              : i.fragment && !Mo.test(i.fragment)
                ? r("Invalid fragment " + i.fragment + " in surface: " + e)
                : i
            : r("Invalid authority " + i.authority + " in surface: " + e)
          : r(
              "Unsupported surface type " + i.surfaceType + " in surface: " + e,
            );
    },
    Uo = (e) => !!e && 0 === e.indexOf(Po + Ro) && -1 === e.indexOf("#"),
    jo = "https://ns.adobe.com/personalization/default-content-item",
    _o = "https://ns.adobe.com/personalization/dom-action",
    Fo = "https://ns.adobe.com/personalization/html-content-item",
    Bo = "https://ns.adobe.com/personalization/json-content-item",
    Vo = "https://ns.adobe.com/personalization/ruleset-item",
    Ho = "https://ns.adobe.com/personalization/redirect-item",
    zo = "https://ns.adobe.com/personalization/message/in-app",
    Jo = (e) => e.filter((t, n) => e.indexOf(t) === n);
  var Go = ({
    getPageLocation: t,
    renderDecisions: n,
    decisionScopes: r,
    personalization: o,
    event: i,
    isCacheInitialized: a,
    logger: s,
  }) => {
    const c = i.getViewName();
    return {
      isRenderDecisions: () => n,
      isSendDisplayEvent: () => !!o.sendDisplayEvent,
      shouldIncludeRenderedPropositions: () => !!o.includeRenderedPropositions,
      getViewName: () => c,
      hasScopes: () => r.length > 0 || w(o.decisionScopes),
      hasSurfaces: () => w(o.surfaces),
      hasViewName: () => de(c),
      createQueryDetails() {
        const n = [...r];
        w(o.decisionScopes) && n.push(...o.decisionScopes);
        const i = ((t = [], n, r) =>
          t
            .map((e) => Lo(e, n, r))
            .filter((t) => !e(t))
            .map(xo))(o.surfaces, t, s);
        this.shouldRequestDefaultPersonalization() &&
          (((e) => {
            e.includes(Zt) || e.push(Zt);
          })(n),
          ((e, t) => {
            const n = qo(t);
            e.includes(n) || e.push(n);
          })(i, t));
        const a = [
          jo,
          Fo,
          Bo,
          Ho,
          Vo,
          zo,
          "https://ns.adobe.com/personalization/message/content-card",
        ];
        return (
          n.includes(Zt) && a.push(_o),
          { schemas: a, decisionScopes: Jo(n), surfaces: Jo(i) }
        );
      },
      isCacheInitialized: () => a,
      shouldFetchData() {
        return (
          this.hasScopes() ||
          this.hasSurfaces() ||
          this.shouldRequestDefaultPersonalization()
        );
      },
      shouldUseCachedData() {
        return this.hasViewName() && !this.shouldFetchData();
      },
      shouldRequestDefaultPersonalization() {
        return (
          o.defaultPersonalizationEnabled ||
          (!this.isCacheInitialized() && !1 !== o.defaultPersonalizationEnabled)
        );
      },
    };
  };
  const Qo = "decisioning.propositionDisplay",
    Xo = "decisioning.propositionInteract",
    Wo = "decisioning.propositionTrigger",
    Yo = "decisioning.propositionDismiss",
    Ko = "decisioning.propositionSuppressDisplay",
    $o = {
      DISPLAY: "display",
      INTERACT: "interact",
      TRIGGER: "trigger",
      DISMISS: "dismiss",
      SUPPRESS: "suppressDisplay",
    },
    Zo = {
      [Qo]: $o.DISPLAY,
      [Xo]: $o.INTERACT,
      [Wo]: $o.TRIGGER,
      [Yo]: $o.DISMISS,
      [Ko]: $o.SUPPRESS,
    },
    ei = {
      [$o.DISPLAY]: Qo,
      [$o.INTERACT]: Xo,
      [$o.TRIGGER]: Wo,
      [$o.DISMISS]: Yo,
      [$o.SUPPRESS]: Ko,
    },
    ti = (e) => Zo[e],
    ni = (e) => ei[e],
    ri = { propositions: [] };
  var oi = ({
      getPageLocation: e,
      logger: t,
      fetchDataHandler: n,
      viewChangeHandler: r,
      onClickHandler: o,
      isAuthoringModeEnabled: i,
      mergeQuery: a,
      viewCache: s,
      showContainers: c,
      applyPropositions: d,
      setTargetMigration: l,
      mergeDecisionsMeta: u,
      renderedPropositions: p,
      onDecisionHandler: g,
      handleConsentFlicker: m,
    }) => ({
      lifecycle: {
        onComponentsRegistered() {
          m();
        },
        onDecision: g,
        onBeforeRequest: ({ request: e }) => (l(e), Promise.resolve()),
        onBeforeEvent({
          event: o,
          renderDecisions: d,
          decisionScopes: l = [],
          personalization: g = {},
          onResponse: m = le,
          onRequestFailure: f = le,
        }) {
          if ((m(() => ({ propositions: [] })), f(() => c()), i()))
            return (
              t.warn("Rendering is disabled for authoring mode."),
              a(o, { enabled: !1 }),
              Promise.resolve()
            );
          const h = Go({
              getPageLocation: e,
              renderDecisions: d,
              decisionScopes: l,
              personalization: g,
              event: o,
              isCacheInitialized: s.isInitialized(),
              logger: t,
            }),
            y = [];
          if (
            (h.shouldIncludeRenderedPropositions() && y.push(p.clear()),
            h.shouldFetchData())
          ) {
            const e = s.createCacheUpdate(h.getViewName());
            (f(() => e.cancel()),
              n({
                cacheUpdate: e,
                personalizationDetails: h,
                event: o,
                onResponse: m,
              }));
          } else
            h.shouldUseCachedData() &&
              y.push(
                r({
                  personalizationDetails: h,
                  event: o,
                  onResponse: m,
                  onRequestFailure: f,
                }),
              );
          return Promise.all(y).then((e) => {
            const t = e.flatMap((e) => e);
            w(t) && u(o, t, [$o.DISPLAY]);
          });
        },
        onClick({ event: e, clickedElement: t }) {
          o({ event: e, clickedElement: t });
        },
      },
      commands: {
        applyPropositions: {
          optionsValidator: (e) =>
            (({ logger: e, options: t }) => {
              const n = bt({
                propositions: ft(
                  bt({
                    id: Et().required(),
                    scope: Et().required(),
                    scopeDetails: bt({
                      decisionProvider: Et().required(),
                    }).required(),
                    items: ft(
                      bt({
                        id: Et().required(),
                        schema: Et().required(),
                        data: bt(mt()),
                      }),
                    )
                      .nonEmpty()
                      .required(),
                  }).required(),
                )
                  .nonEmpty()
                  .required(),
                metadata: bt(mt()),
                viewName: Et(),
              }).required();
              try {
                return n(t);
              } catch (t) {
                return (
                  e.warn(
                    "Invalid options for applyPropositions. No propositions will be applied.",
                    t,
                  ),
                  ri
                );
              }
            })({ logger: t, options: e }),
          run: d,
        },
      },
    }),
    ii = (e = "undefined") => g("DIV", {}, { innerHTML: e });
  const ai = /:eq\((\d+)\)/g,
    si = (e) => -1 === e.indexOf(":eq("),
    ci = /(#|\.)(-?\w+)/g,
    di = (e, t, n) => "" + t + CSS.escape(n),
    li = (e) => {
      const t = [],
        n = ((e) => e.split(ai).filter(de))(
          ((e) => e.replace(ci, di))(e.trim()),
        ),
        { length: r } = n;
      let o = 0;
      for (; o < r; ) {
        const e = n[o],
          r = n[o + 1];
        (r ? t.push({ sel: e, eq: Number(r) }) : t.push({ sel: e }), (o += 2));
      }
      return t;
    },
    ui = (e) => {
      const t = document;
      if (si(e)) return P(e, t);
      const n = li(e),
        { length: r } = n;
      let o = [],
        i = t,
        a = 0;
      for (; a < r; ) {
        const { sel: e, eq: t } = n[a],
          s = P(e, i),
          { length: c } = s;
        if (0 === c) break;
        if (null != t && t > c - 1) break;
        (a < r - 1 && (null == t ? ([i] = s) : (i = s[t])),
          a === r - 1 && (o = null == t ? s : [s[t]]),
          (a += 1));
      }
      return o;
    };
  var pi = (e, t = document) => t.getElementById(e),
    gi = (e, t, n) => {
      e.setAttribute(t, n);
    },
    mi = (e, t) => e.getAttribute(t),
    fi = (e, t, n, r) => {
      let o;
      ((o = r ? t + ":" + n + " !" + r + ";" : t + ":" + n + ";"),
        (e.style.cssText += ";" + o));
    },
    hi = (e) => e.parentNode,
    yi = (e, t) => {
      if (!e) return;
      const n = hi(e);
      n && n.insertBefore(t, ((e) => e.nextElementSibling)(e));
    },
    vi = (e, t) => {
      if (!e) return;
      const n = hi(e);
      n && n.insertBefore(t, e);
    },
    wi = (e) => {
      const { childNodes: t } = e;
      return t ? I(t) : [];
    },
    Ii = (e) => e.firstElementChild;
  let bi;
  var Ei = (e = document) => {
    if (void 0 === bi) {
      const t = e.querySelector("[nonce]");
      bi = t && (t.nonce || t.getAttribute("nonce"));
    }
    return bi;
  };
  const Ci = "src",
    ki = (e) => g(m, { src: e }),
    Si = (e) => {
      P(m, e).forEach((e) => {
        const t = mi(e, Ci);
        t && ki(t);
      });
    },
    Pi = (e) => ((e, t) => e.tagName === t)(e, f) && !mi(e, Ci);
  var Di = (e) => {
    const t = P(f, e),
      { length: n } = t,
      r = Ei();
    if (r)
      for (let e = 0; e < n; e += 1) {
        const n = t[e];
        Pi(n) && (n.nonce = r);
      }
  };
  const Ri = (e) => {
      const t = document.createElement("script");
      ((t.src = e), (t.async = !0));
      const n = ((e, t) =>
        new Promise((n, r) => {
          ((t.onload = () => {
            n(t);
          }),
            (t.onerror = () => {
              r(new Error("Failed to load script: " + e));
            }));
        }))(e, t);
      return (document.head.appendChild(t), n);
    },
    Ti = (e, t) => !!e && e.tagName === t,
    Oi = (e) => Ti(e, h) && !mi(e, Ci),
    Ni = (e) => Ti(e, h) && mi(e, Ci),
    Mi = (e) => {
      const t = P(h, e),
        n = [],
        { length: r } = t,
        o = Ei(),
        i = { ...(o && { nonce: o }) };
      for (let e = 0; e < r; e += 1) {
        const r = t[e];
        if (!Oi(r)) continue;
        const { textContent: o } = r;
        o && n.push(g(h, i, { textContent: o }));
      }
      return n;
    },
    Ai = (e) => {
      const t = P(h, e),
        n = [],
        { length: r } = t;
      for (let e = 0; e < r; e += 1) {
        const r = t[e];
        if (!Ni(r)) continue;
        const o = mi(r, Ci);
        o && n.push(o);
      }
      return n;
    },
    xi = (e, t) => {
      t.forEach((t) => {
        (e.appendChild(t), e.removeChild(t));
      });
    },
    qi = (e) => Promise.all(e.map(Ri));
  var Li = (e, t, n) => {
    const r = ii(t);
    Di(r);
    const o = wi(r),
      i = Mi(r),
      a = Ai(r);
    return (
      Si(r),
      o.forEach((t) => {
        p(e, t);
      }),
      n(e),
      xi(e, i),
      qi(a)
    );
  };
  var Ui = (e, t, n) => (
      ((e) => {
        wi(e).forEach(q);
      })(e),
      Li(e, t, n)
    ),
    ji = (e, t, n) => {
      const r = ii(t);
      Di(r);
      const o = wi(r),
        i = Mi(r),
        a = Ai(r),
        { length: s } = o;
      let c = s - 1;
      for (Si(r); c >= 0; ) {
        const t = o[c];
        n(t);
        const r = Ii(e);
        (r ? vi(r, t) : p(e, t), (c -= 1));
      }
      return (xi(e, i), qi(a));
    };
  const _i = "alloy-prehiding",
    Fi = {},
    Bi = (e) => {
      if (Fi[e]) return;
      const t = Ei(),
        n = { ...(t && { nonce: t }) },
        r = g(f, n, { textContent: e + " { visibility: hidden }" });
      (p(document.head, r), (Fi[e] = r));
    },
    Vi = (e) => {
      const t = Fi[e];
      t && (q(t), delete Fi[e]);
    };
  var Hi = (e, t, n) => {
      (n(e), (e.textContent = t));
    },
    zi = (e, t, n) => {
      const r = ii(t);
      Di(r);
      const o = wi(r),
        i = Mi(r),
        a = Ai(r);
      return (
        Si(r),
        o.forEach((t) => {
          (n(t), vi(e, t));
        }),
        xi(e, i),
        qi(a)
      );
    },
    Ji = (e, t, n) =>
      zi(e, t, n).then(() => {
        q(e);
      }),
    Gi = (e, t, n) => {
      const r = ii(t);
      Di(r);
      const o = wi(r),
        i = Mi(r),
        a = Ai(r);
      Si(r);
      let s = e;
      return (
        o.forEach((e) => {
          (n(e), yi(s, e), (s = e));
        }),
        xi(e, i),
        qi(a)
      );
    },
    Qi = (e, t, n) => {
      const { priority: r, ...o } = t;
      (Object.keys(o).forEach((t) => {
        fi(e, t, o[t], r);
      }),
        n(e));
    },
    Xi = (e, t, n) => {
      (Object.keys(t).forEach((n) => {
        gi(e, n, t[n]);
      }),
        n(e));
    },
    Wi = (e, t, n) => {
      e.tagName === m &&
        (ki(t),
        n(e),
        ((e, t) => {
          e.removeAttribute(t);
        })(e, Ci),
        gi(e, Ci, t));
    },
    Yi = (e, { from: t, to: n }, r) => {
      const o = ((e) => {
          const { children: t } = e;
          return t ? I(t) : [];
        })(e),
        i = o[t],
        a = o[n];
      i && a && (t < n ? yi(a, i) : vi(a, i), r(a), r(i));
    };
  const Ki = (e) => async (t, n, r) => {
      const { selector: o, prehidingSelector: i, content: a } = t;
      Bi(i);
      try {
        (({
          containers: e,
          content: t,
          decorateProposition: n,
          renderFunc: r,
          renderStatusHandler: o,
        }) => {
          const i = e.filter(o.shouldRender).map(async (e) => {
            (await r(e, t, n), o.markAsRendered(e));
          });
          Promise.all(i);
        })({
          containers: await N(o, ui),
          content: a,
          decorateProposition: n,
          renderFunc: e,
          renderStatusHandler: r,
        });
      } finally {
        Vi(i);
      }
    },
    $i = (e) => (("" + e).endsWith("px") ? e : e + "px");
  var Zi = (e, t, n) => {
      const { priority: r, ...o } = t;
      (Object.keys(o).forEach((t) => {
        let n = o[t];
        (("left" !== t && "top" !== t) || (n = $i(n)), fi(e, t, n, r));
      }),
        n(e));
    },
    ea = (e, t, n) => {
      n(e);
    },
    ta = (e, t, n) => {
      const { priority: r, ...o } = t;
      (Object.keys(o).forEach((t) => {
        let n = o[t];
        (("width" !== t && "height" !== t) || (n = $i(n)), fi(e, t, n, r));
      }),
        n(e));
    };
  const na = "setHtml",
    ra = "customCode",
    oa = "setText",
    ia = "setAttribute",
    aa = "setImageSource",
    sa = "setStyle",
    ca = "move",
    da = "resize",
    la = "rearrange",
    ua = "remove",
    pa = "insertAfter",
    ga = "insertBefore",
    ma = "replaceHtml",
    fa = "prependHtml",
    ha = "appendHtml",
    ya = "click",
    va = "collectInteractions";
  var wa =
    ({ eventManager: e, mergeDecisionsMeta: t }) =>
    ({
      decisionsMeta: n = [],
      propositionAction: r,
      documentMayUnload: o = !1,
      eventType: i = Qo,
      propositionEventTypes: a = [ti(i)],
      viewName: s,
    }) => {
      const c = e.createEvent(),
        d = { eventType: i };
      return (
        s && (d.web = { webPageDetails: { viewName: s } }),
        w(n) && t(c, n, a, r),
        c.mergeXdm(d),
        o && c.documentMayUnload(),
        e.sendEvent(c)
      );
    };
  var Ia = (e, t) => {
    if (si(e))
      return ((e, t) => (t.matches ? t.matches(e) : t.msMatchesSelector(e)))(
        e,
        t,
      );
    const n = ui(e);
    let r = !1;
    for (let e = 0; e < n.length; e += 1)
      if (n[e] === t) {
        r = !0;
        break;
      }
    return r;
  };
  const ba = "view",
    Ea = (e) =>
      e.map((e) => {
        const { trackingLabel: t, scopeType: n, ...r } = e;
        return r;
      }),
    Ca = (e, t, n) => {
      const { documentElement: r } = document;
      let o = e,
        i = 0;
      for (; o && o !== r; ) {
        if (Ia(t, o)) {
          const e = n(t),
            r = { metas: e },
            o = e.find((e) => e.trackingLabel);
          o && ((r.label = o.trackingLabel), (r.weight = i));
          const a = e.find((e) => e.scopeType === ba);
          return (a && ((r.viewName = a.scope), (r.weight = i)), r);
        }
        ((o = o.parentNode), (i += 1));
      }
      return { metas: null };
    };
  var ka = (e, t, n) => {
      const r = [];
      let o,
        i = "",
        a = Number.MAX_SAFE_INTEGER,
        s = Number.MAX_SAFE_INTEGER;
      for (let c = 0; c < t.length; c += 1) {
        const { metas: d, label: l, weight: u, viewName: p } = Ca(e, t[c], n);
        d &&
          (l && u <= a && ((i = l), (a = u)),
          p && u <= s && ((o = p), (s = u)),
          r.push(...Ea(d)));
      }
      return {
        decisionsMeta:
          ((c = r),
          c.filter((e, t) => {
            const n = JSON.stringify(e);
            return t === c.findIndex((e) => JSON.stringify(e) === n);
          })),
        propositionActionLabel: i,
        propositionActionToken: void 0,
        viewName: o,
      };
      var c;
    },
    Sa = (e = document) =>
      -1 !== e.location.href.indexOf("adobe_authoring_enabled");
  const Pa = (e, t, n, r) => {
      if (0 === t.length) return;
      const o = {};
      n.forEach((e) => {
        o[e] = 1;
      });
      const i = {
        _experience: {
          decisioning: { propositions: t, propositionEventType: o },
        },
      };
      (r && (i._experience.decisioning.propositionAction = r), e.mergeXdm(i));
    },
    Da = (e, t) => {
      e.mergeQuery({ personalization: { ...t } });
    };
  var Ra = () => {
    const e = {};
    return {
      storeClickMeta: ({
        selector: t,
        meta: {
          id: n,
          scope: r,
          scopeDetails: o,
          trackingLabel: i,
          scopeType: a,
        },
      }) => {
        (e[t] || (e[t] = {}),
          (e[t][n] = {
            scope: r,
            scopeDetails: o,
            trackingLabel: i,
            scopeType: a,
          }));
      },
      getClickSelectors: () => Object.keys(e),
      getClickMetas: (t) =>
        e[t]
          ? ((e) => Object.keys(e).map((t) => ({ id: t, ...e[t] })))(e[t])
          : {},
    };
  };
  const Ta = (e, t) => e === Bo && t === va,
    Oa = {
      [_o]: () => !0,
      [Fo]: () => !0,
      [Bo]: Ta,
      [zo]: () => !0,
      [jo]: () => !0,
    };
  var Na = ({
    processPropositions: e,
    createProposition: t,
    renderedPropositions: n,
    viewCache: r,
  }) => {
    const o = ({ items: e, metadataForScope: t = {} }) => {
        const { actionType: n, selector: r } = t;
        return e
          .filter((e) =>
            ((e, t) => "function" == typeof Oa[e] && Oa[e](e, t))(e.schema, n),
          )
          .map((e) => {
            const { schema: o } = e;
            return o === Fo || Ta(o, n)
              ? j(t)
                ? void 0
                : {
                    ...e,
                    schema: Ta(o, n) ? _o : o,
                    data: { ...e.data, selector: r, type: n },
                  }
              : { ...e };
          })
          .filter((e) => e);
      },
      i = (e) => !(e.scope === Zt && e.renderAttempted);
    return ({ propositions: a = [], metadata: s = {}, viewName: c }) => {
      const d = l();
      n.concat(d.promise);
      const u = (({ propositions: e, metadata: t }) =>
        e
          .filter(i)
          .map((e) => {
            if (w(e.items)) {
              const { id: n, scope: r, scopeDetails: i } = e;
              return {
                id: n,
                scope: r,
                scopeDetails: i,
                items: o({ items: e.items, metadataForScope: t[e.scope] }),
              };
            }
            return e;
          })
          .filter((e) => w(e.items)))({ propositions: a, metadata: s }).map(
        (e) => t(e),
      );
      return Promise.resolve()
        .then(() => (c ? r.getView(c) : []))
        .then((t) => {
          const { render: n, returnedPropositions: r } = e([...u, ...t]);
          return (n().then(d.resolve), { propositions: r });
        });
    };
  };
  var Ma = (e) => {
    const { selector: t, type: n } = e;
    return n !== ra || "BODY > *:eq(0)" !== t ? e : { ...e, selector: "BODY" };
  };
  var Aa = (e) => {
      const t = { ...e },
        { content: n, selector: r } = t;
      if (ro(n)) return t;
      if (null == r) return t;
      const o = ui(r);
      return Ti(o[0], "HEAD")
        ? ((t.type = ha),
          (t.content = ((e) => {
            const t = ii(e);
            return P("SCRIPT,LINK,STYLE", t)
              .map((e) => e.outerHTML)
              .join("");
          })(n)),
          t)
        : t;
    },
    xa =
      ({ preprocess: e, isPageWideSurface: t }) =>
      (n, r = !0, o = !1) => {
        const { id: i, scope: a, scopeDetails: s, items: c = [] } = n,
          { characteristics: { scopeType: d } = {} } = s || {};
        return {
          getScope: () => a,
          getScopeType: () =>
            a === Zt || t(a) ? "page" : d === ba ? ba : "proposition",
          getItems() {
            return c.map((t) =>
              ((t, n) => {
                const {
                    id: r,
                    schema: o,
                    data: i,
                    characteristics: { trackingLabel: a } = {},
                  } = t,
                  s = i ? i.type : void 0,
                  c = e(i);
                return {
                  getId: () => r,
                  getSchema: () => o,
                  getSchemaType: () => s,
                  getData: () => c,
                  getProposition: () => n,
                  getTrackingLabel: () => a,
                  getOriginalItem: () => t,
                  toString: () => JSON.stringify(t),
                  toJSON: () => t,
                };
              })(t, this),
            );
          },
          getNotification: () => ({ id: i, scope: a, scopeDetails: s }),
          getId: () => i,
          toJSON: () => n,
          shouldSuppressDisplay: () => o,
          addToReturnValues(e, t, o, i) {
            r &&
              (e.push({
                ...n,
                items: o.map((e) => e.getOriginalItem()),
                renderAttempted: i,
              }),
              i || t.push({ ...n, items: o.map((e) => e.getOriginalItem()) }));
          },
        };
      },
    qa = () => ({
      render: le,
      setRenderAttempted: !0,
      includeInNotification: !0,
    });
  const La = "always",
    Ua = "never",
    ja = "decoratedElementsOnly",
    _a = [La, Ua, ja],
    Fa = "data-aep-interact-id",
    Ba = "data-aep-click-label";
  let Va = 0;
  const Ha = (e, t, n, r, o, i, a, s) => {
    const { scopeDetails: c = {} } = a,
      { decisionProvider: d } = c;
    return ((e, t) => !!e && !!e[t] && [La, ja].includes(e[t]))(e, d) ||
      t === ya
      ? (e) => {
          if (!e.tagName) return;
          const t = (c = mi(e, Fa)) ? parseInt(c, 10) : ++Va;
          var c;
          (s(n, r, i, a, t), gi(e, Fa, t), o && !mi(e, Ba) && gi(e, Ba, o));
        }
      : le;
  };
  var za = (e, t) =>
      e !== ba
        ? { shouldRender: () => !0, markAsRendered: () => {} }
        : {
            shouldRender: (e) => {
              if (!e) return !0;
              return !(e.dataset.adobePropositionIds ?? "")
                .split(",")
                .includes(t);
            },
            markAsRendered: (e) => {
              const n = (e.dataset.adobePropositionIds ?? "").split(",");
              (n.includes(t) || n.push(t),
                (e.dataset.adobePropositionIds = n.sort().join(",")));
            },
          },
    Ja =
      ({
        modules: e,
        logger: t,
        storeInteractionMeta: n,
        storeClickMeta: r,
        autoCollectPropositionInteractions: o,
      }) =>
      (i) => {
        const { type: a, selector: s } = i.getData() || {};
        if (!a)
          return (
            t.warn("Invalid DOM action data: missing type.", i.getData()),
            { setRenderAttempted: !1, includeInNotification: !1 }
          );
        if (a === ya)
          return s
            ? (r({
                selector: s,
                meta: {
                  ...i.getProposition().getNotification(),
                  trackingLabel: i.getTrackingLabel(),
                  scopeType: i.getProposition().getScopeType(),
                },
              }),
              { setRenderAttempted: !0, includeInNotification: !1 })
            : (t.warn(
                "Invalid DOM action data: missing selector.",
                i.getData(),
              ),
              { setRenderAttempted: !1, includeInNotification: !1 });
        if (!e[a])
          return (
            t.warn("Invalid DOM action data: unknown type.", i.getData()),
            { setRenderAttempted: !1, includeInNotification: !1 }
          );
        const c = za(i.getProposition().getScopeType(), i.getId()),
          d = Ha(
            o,
            a,
            i.getProposition().getId(),
            i.getId(),
            i.getTrackingLabel(),
            i.getProposition().getScopeType(),
            i.getProposition().getNotification(),
            n,
          );
        return {
          render: () => e[a](i.getData(), d, c),
          setRenderAttempted: !0,
          includeInNotification: !0,
        };
      },
    Ga =
      ({
        modules: e,
        logger: t,
        storeInteractionMeta: n,
        autoCollectPropositionInteractions: r,
      }) =>
      (o) => {
        const { type: i, selector: a } = o.getData() || {};
        if (!a || !i)
          return { setRenderAttempted: !1, includeInNotification: !1 };
        if (!e[i])
          return (
            t.warn("Invalid HTML content data", o.getData()),
            { setRenderAttempted: !1, includeInNotification: !1 }
          );
        const s = Ha(
            r,
            i,
            o.getProposition().getId(),
            o.getId(),
            o.getTrackingLabel(),
            o.getProposition().getScopeType(),
            o.getProposition().getNotification(),
            n,
          ),
          c = za(o.getProposition().getScopeType(), o.getId());
        return {
          render: () => e[i](o.getData(), s, c),
          setRenderAttempted: !0,
          includeInNotification: !0,
        };
      };
  const Qa = "BODY";
  var Xa =
      ({ logger: e, executeRedirect: t, collect: n }) =>
      (r) => {
        const { content: o } = r.getData() || {};
        if (!o) return (e.warn("Invalid Redirect data", r.getData()), {});
        return {
          render: () => (
            Bi(Qa),
            n({
              decisionsMeta: [r.getProposition().getNotification()],
              documentMayUnload: !0,
            })
              .then(
                () => (
                  e.logOnContentRendering({
                    status: "rendering-redirect",
                    detail: {
                      propositionDetails: r.getProposition().getNotification(),
                      redirect: o,
                    },
                    message: "Redirect action " + r.toString() + " executed.",
                    logLevel: "info",
                  }),
                  t(o)
                ),
              )
              .catch((e) => {
                throw (Vi(Qa), e);
              })
          ),
          setRenderAttempted: !0,
          onlyRenderThis: !0,
        };
      },
    Wa = ({ schemaProcessors: e, logger: t }) => {
      const n = (e, n) => () =>
          Promise.resolve()
            .then(e)
            .then(
              () => (
                t.enabled && t.info("Action " + n.toString() + " executed."),
                n.toJSON()
              ),
            )
            .catch((e) => {
              const { message: r, stack: o } = e,
                i =
                  "Failed to execute action " +
                  n.toString() +
                  ". " +
                  r +
                  " " +
                  o;
              t.logOnContentRendering({
                status: "rendering-failed",
                detail: {
                  propositionDetails: n.getProposition().getNotification(),
                  item: n.toJSON(),
                },
                error: e,
                message: i,
                logLevel: "warn",
              });
            }),
        r = (t) => {
          const n = e[t.getSchema()];
          return n ? n(t) : {};
        },
        o = ({
          renderers: e,
          returnedPropositions: t,
          returnedDecisions: o,
          items: i,
          proposition: a,
        }) => {
          let s,
            c,
            d,
            l,
            u = [...e],
            p = [...t],
            g = [...o],
            m = [],
            f = [],
            h = [],
            y = !1,
            v = !1,
            I = 0;
          for (; i.length > I; ) {
            if (
              ((l = i[I]),
              ({
                render: s,
                setRenderAttempted: c,
                includeInNotification: d,
                onlyRenderThis: v,
              } = r(l)),
              v)
            ) {
              ((p = []),
                (g = []),
                c ? ((m = [l]), (f = [])) : ((m = []), (f = [l])),
                (u = []),
                (h = [s]),
                (y = d));
              break;
            }
            (s && h.push(n(s, l)),
              d && (y = !0),
              c ? m.push(l) : f.push(l),
              (I += 1));
          }
          if (h.length > 0) {
            const e = y ? a.getNotification() : void 0;
            u.push(() =>
              (async (e, t) => {
                const n = (await Promise.allSettled(e.map((e) => e())))
                  .filter((e) => "fulfilled" === e.status)
                  .map((e) => e.value);
                if (t && w(n)) return { ...t, items: n };
              })(h, e),
            );
          } else y && u.push(() => Promise.resolve(a.getNotification()));
          return (
            m.length > 0 && a.addToReturnValues(p, g, m, !0),
            f.length > 0 && a.addToReturnValues(p, g, f, !1),
            {
              renderers: u,
              returnedPropositions: p,
              returnedDecisions: g,
              onlyRenderThis: v,
            }
          );
        };
      return (e, n = []) => {
        let r,
          i,
          a,
          s = [],
          c = [],
          d = [],
          l = 0;
        for (
          ;
          e.length > l &&
          ((i = e[l]),
          (a = i.getItems()),
          ({
            renderers: s,
            returnedPropositions: c,
            returnedDecisions: d,
            onlyRenderThis: r,
          } = o({
            renderers: s,
            returnedPropositions: c,
            returnedDecisions: d,
            items: a,
            proposition: i,
          })),
          !r);

        )
          l += 1;
        (r &&
          e.forEach((e, t) => {
            t !== l && e.addToReturnValues(c, d, e.getItems(), !1);
          }),
          n.forEach((e) => {
            e.addToReturnValues(c, d, e.getItems(), !1);
          }));
        return {
          returnedPropositions: c,
          returnedDecisions: d,
          render: () =>
            Promise.all(s.map((e) => e())).then((e) => {
              const n = e.filter((e) => e),
                r = n.map((e) => {
                  const { id: t, scope: n, scopeDetails: r } = e;
                  return { id: t, scope: n, scopeDetails: r };
                });
              if (w(n)) {
                const e = G(n, (e) => e.scope);
                t.logOnContentRendering({
                  status: "rendering-succeeded",
                  detail: { ...e },
                  message:
                    "Scopes: " + JSON.stringify(e) + " successfully executed.",
                  logLevel: "info",
                });
              }
              return r;
            }),
        };
      };
    };
  var Ya =
    ({
      processPropositions: e,
      createProposition: t,
      notificationHandler: n,
    }) =>
    ({
      renderDecisions: r,
      propositions: o,
      event: i,
      personalization: a = {},
    }) => {
      if (!r) return Promise.resolve();
      const { sendDisplayEvent: s = !0 } = a,
        c = i ? i.getViewName() : void 0,
        d = (() => {
          let e = 0;
          return (t) => {
            const { items: n = [] } = t;
            return !!n.some((e) => e.schema === zo) && ((e += 1), e > 1);
          };
        })(),
        l = o.map((e) => t(e, !0, d(e))),
        { render: u, returnedPropositions: p } = e(l),
        g = n(r, s, c),
        m = l.reduce((e, t) => ((e[t.getId()] = t), e), {});
      return (
        u().then((e) => {
          const t = e.filter((e) => !m[e.id].shouldSuppressDisplay()),
            n = e.filter((e) => m[e.id].shouldSuppressDisplay());
          g(t, n);
        }),
        Promise.resolve({ propositions: p })
      );
    };
  const Ka = "text/html",
    $a = "defaultContent",
    Za = ["content", "contentType"],
    es = ["mobileParameters", "webParameters", "html"];
  var ts =
    ({ modules: e, logger: t }) =>
    (n) => {
      const r = n.getData(),
        o = n.getProposition(),
        i = { ...o.getNotification() },
        a = o.shouldSuppressDisplay();
      if (!r) return (t.warn("Invalid in-app message data: undefined.", r), {});
      const { type: s = $a } = r;
      return e[s]
        ? ((e, t) => {
            for (let n = 0; n < Za.length; n += 1) {
              const r = Za[n];
              if (!Object.prototype.hasOwnProperty.call(e, r))
                return (
                  t.warn(
                    "Invalid in-app message data: missing property '" +
                      r +
                      "'.",
                    e,
                  ),
                  !1
                );
            }
            const { content: n, contentType: r } = e;
            if ("application/json" === r)
              for (let r = 0; r < es.length; r += 1) {
                const o = es[r];
                if (!Object.prototype.hasOwnProperty.call(n, o))
                  return (
                    t.warn(
                      "Invalid in-app message data.content: missing property '" +
                        o +
                        "'.",
                      e,
                    ),
                    !1
                  );
              }
            return !0;
          })(r, t)
          ? i
            ? {
                render: () => (a ? null : e[s]({ ...r, meta: i })),
                setRenderAttempted: !0,
                includeInNotification: !0,
              }
            : (t.warn("Invalid in-app message meta: undefined.", i), {})
          : {}
        : (t.warn("Invalid in-app message data: unknown type.", r), {});
    };
  const ns = (e) => {
    const t = P("#" + e, document);
    t && t.length > 0 && q(t[0]);
  };
  var rs =
    (e) =>
    (t, n = !1) => (
      n ? (e.location.href = t) : e.location.replace(t),
      new Promise(() => {})
    );
  const os = "alloy-messaging-container",
    is = "alloy-overlay-container",
    as = "alloy-content-iframe",
    ss = () => [os, is].forEach(ns),
    cs =
      (e, t = rs(window)) =>
      (n) => {
        (n.preventDefault(), n.stopImmediatePropagation());
        const { target: r } = n,
          o = "a" === r.tagName.toLowerCase() ? r : r.closest("a");
        if (!o) return;
        const {
          action: i,
          interaction: a,
          link: s,
          label: c,
          uuid: d,
        } = ((e) => {
          const t = {};
          if (!e || "a" !== e.tagName.toLowerCase()) return t;
          const { href: n } = e;
          if (!n || !n.startsWith("adbinapp://")) return t;
          const r = n.split("?"),
            o = r[0].split("://")[1],
            i = e.innerText,
            a = e.getAttribute("data-uuid") || "";
          let s, c;
          if (w(r)) {
            const e = ye.parse(r[1]);
            ((s = e.interaction || ""), (c = Bn(e.link || "")));
          }
          return { action: o, interaction: s, link: c, label: i, uuid: a };
        })(o);
        (e(i, { label: c, id: a, uuid: d, link: s }),
          "dismiss" === i && ss(),
          de(s) && s.length > 0 && t(s, !0));
      },
    ds = (e) => {
      const {
          verticalAlign: t,
          width: n,
          horizontalAlign: r,
          backdropColor: o,
          height: i,
          cornerRadius: a,
          horizontalInset: s,
          verticalInset: c,
          uiTakeover: d = !1,
        } = e,
        l = {
          width: n ? n + "%" : "100%",
          backgroundColor: o || "rgba(0, 0, 0, 0.5)",
          borderRadius: a ? a + "px" : "0px",
          border: "none",
          position: d ? "fixed" : "relative",
          overflow: "hidden",
        };
      return (
        "left" === r
          ? (l.left = s ? s + "%" : "0")
          : "right" === r
            ? (l.right = s ? s + "%" : "0")
            : "center" === r &&
              ((l.left = "50%"), (l.transform = "translateX(-50%)")),
        "top" === t
          ? (l.top = c ? c + "%" : "0")
          : "bottom" === t
            ? ((l.position = "fixed"), (l.bottom = c ? c + "%" : "0"))
            : "center" === t &&
              ((l.top = "50%"),
              (l.transform =
                ("center" === r ? l.transform + " " : "") + "translateY(-50%)"),
              (l.display = "flex"),
              (l.alignItems = "center"),
              (l.justifyContent = "center")),
        (l.height = i ? i + "vh" : "100%"),
        l
      );
    },
    ls = (e) => {
      const { backdropOpacity: t, backdropColor: n } = e;
      return {
        position: "fixed",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        background: "transparent",
        opacity: t || 0.5,
        backgroundColor: n || "#FFFFFF",
      };
    },
    us = ["enabled", "parentElement", "insertionMethod"],
    ps = (e = {}, t) => {
      ss();
      const { content: n, contentType: r, mobileParameters: o } = e;
      let { webParameters: i } = e;
      if (r !== Ka) return;
      const a = g("div", { id: os }),
        s = ((e, t) => {
          const n = new DOMParser().parseFromString(e, Ka),
            r = n.querySelector("script");
          r && r.setAttribute("nonce", Ei());
          const o = g("iframe", {
            src: URL.createObjectURL(
              new Blob([n.documentElement.outerHTML], { type: "text/html" }),
            ),
            id: as,
          });
          return (
            o.addEventListener("load", () => {
              const { addEventListener: e } =
                o.contentDocument || o.contentWindow.document;
              e("click", t);
            }),
            o
          );
        })(n, cs(t)),
        c = g("div", { id: is });
      (((e) => {
        if (!e) return !1;
        const t = Object.keys(e);
        if (!t.includes(os)) return !1;
        if (!t.includes(is)) return !1;
        const n = Object.values(e);
        for (let e = 0; e < n.length; e += 1) {
          if (!bt(n[e], "style")) return !1;
          if (!bt(n[e], "params")) return !1;
          for (let t = 0; t < us.length; t += 1)
            if (!bt(n[e].params, us[t])) return !1;
        }
        return !0;
      })(i) ||
        (i = ((e) => {
          if (!e) return;
          const { uiTakeover: t = !1 } = e;
          return {
            [as]: {
              style: { border: "none", width: "100%", height: "100%" },
              params: {
                enabled: !0,
                parentElement: "#alloy-messaging-container",
                insertionMethod: "appendChild",
              },
            },
            [os]: {
              style: ds(e),
              params: {
                enabled: !0,
                parentElement: "body",
                insertionMethod: "appendChild",
              },
            },
            [is]: {
              style: ls(e),
              params: {
                enabled: !0 === t,
                parentElement: "body",
                insertionMethod: "appendChild",
              },
            },
          };
        })(o)),
        i &&
          ((e, t, n, r) => {
            [
              { id: is, element: r },
              { id: os, element: n },
              { id: as, element: e },
            ].forEach(({ id: e, element: n }) => {
              const { style: r = {}, params: o = {} } = t[e];
              Object.assign(n.style, r);
              const {
                  parentElement: i = "body",
                  insertionMethod: a = "appendChild",
                  enabled: s = !0,
                } = o,
                c = document.querySelector(i);
              s && c && "function" == typeof c[a] && c[a](n);
            });
          })(s, i, a, c));
    };
  var gs = (e) => ({
    defaultContent: (t) =>
      ((e, t) =>
        new Promise((n) => {
          const { meta: r } = e;
          (ps(e, (e, n) => {
            const o = {};
            ((o[$o.INTERACT] = 1),
              -1 !== Object.values($o).indexOf(e) && (o[e] = 1),
              t({
                decisionsMeta: [r],
                propositionAction: n,
                eventType: Xo,
                propositionEventTypes: Object.keys(o),
              }));
          }),
            n({ meta: r }));
        }))(t, e),
  });
  const ms = (e) => {
    const t = e.find((e) => e.scopeType === ba);
    return t ? t.scope : void 0;
  };
  var fs = (e, t, n) => {
    const {
        interactIds: r,
        clickLabel: o = "",
        clickToken: i,
      } = ((e) => {
        const { documentElement: t } = document;
        let n = e;
        const r = new Set();
        let o, i;
        for (; n && n !== t && !(n instanceof ShadowRoot); ) {
          const e = mi(n, Fa);
          (e && r.add(e),
            (o = o || mi(n, Ba)),
            (i = i || mi(n, "data-aep-click-token")),
            (n = n.parentNode));
        }
        return { interactIds: [...r], clickLabel: o, clickToken: i };
      })(e),
      a = ((e, t, n) => (r) => {
        const { scopeDetails: o = {} } = r,
          { decisionProvider: i } = o;
        return e[i] === La || (e[i] === ja && (t || n));
      })(n, o, i);
    if (0 === r.length) return {};
    const s = t(r).filter(a);
    return {
      decisionsMeta: Ea(s),
      propositionActionLabel: o,
      propositionActionToken: i,
      viewName: ms(s),
    };
  };
  const hs = "AJO",
    ys = "TGT",
    vs = ({ config: e, logger: t, eventManager: n, consent: r }) => {
      const {
          targetMigrationEnabled: o,
          prehidingStyle: i,
          autoCollectPropositionInteractions: a,
        } = e,
        s = wa({ eventManager: n, mergeDecisionsMeta: Pa }),
        c = ((e) => () => {
          const t = pi(_i);
          t &&
            (e.logOnContentHiding({
              status: "show-containers",
              message: "Prehiding style removed to show containers.",
              logLevel: "info",
            }),
            q(t));
        })(t),
        d = ((e) => (t) => {
          if (!t) return;
          if (pi(_i)) return;
          const n = Ei(),
            r = { id: _i, ...(n && { nonce: n }) },
            o = g(f, r, { textContent: t });
          (e.logOnContentHiding({
            status: "hide-containers",
            message: "Prehiding style applied to hide containers.",
            logLevel: "info",
          }),
            p(document.head, o));
        })(t),
        { storeInteractionMeta: u, getInteractionMetas: m } = (() => {
          const e = {},
            t = {};
          return {
            storeInteractionMeta: (n, r, o, i, a) => {
              ((a = parseInt(a, 10)),
                e[a] || ((e[a] = {}), (t[a] = {})),
                t[a][n] || (t[a][n] = new Set()),
                t[a][n].add(r),
                (e[a][n] = { ...i, scopeType: o }));
            },
            getInteractionMetas: (n) =>
              Array.isArray(n) && 0 !== n.length
                ? Object.values(
                    n
                      .map((e) => parseInt(e, 10))
                      .reduce(
                        (n, r) => (
                          Object.keys(e[r] || {}).forEach((o) => {
                            (n[o] ||
                              (n[o] = {
                                proposition: e[r][o],
                                items: new Set(),
                              }),
                              (n[o].items = new Set([
                                ...n[o].items,
                                ...t[r][o],
                              ])));
                          }),
                          n
                        ),
                        {},
                      ),
                  ).map(({ proposition: e, items: t }) => ({
                    ...e,
                    items: Array.from(t).map((e) => ({ id: e })),
                  }))
                : [],
          };
        })(),
        { storeClickMeta: h, getClickSelectors: y, getClickMetas: v } = Ra(),
        I = (
          ({ window: e }) =>
          () =>
            e.location
        )({ window: window }),
        b = {
          [na]: Ki(Ui),
          [ra]: Ki(ji),
          [oa]: Ki(Hi),
          [ia]: Ki(Xi),
          [aa]: Ki(Wi),
          [sa]: Ki(Qi),
          [ca]: Ki(Zi),
          [da]: Ki(ta),
          [la]: Ki(Yi),
          [ua]: Ki(q),
          [pa]: Ki(Gi),
          [ga]: Ki(zi),
          [ma]: Ki(Ji),
          [fa]: Ki(ji),
          [ha]: Ki(Li),
          [va]: Ki(ea),
        },
        E =
          ((C = [Aa, Ma]),
          (e) => (e ? C.reduce((e, t) => ({ ...e, ...t(e) }), e) : e));
      var C;
      const k = xa({ preprocess: E, isPageWideSurface: Uo }),
        S = (({ createProposition: e }) => {
          let t = !1,
            n = Promise.resolve({});
          const r = (t, n) => {
            const r = t[n.toLowerCase()];
            return r && r.length > 0
              ? r
              : [
                  e(
                    {
                      scope: n,
                      scopeDetails: { characteristics: { scopeType: ba } },
                      items: [{ schema: jo }],
                    },
                    !1,
                  ),
                ];
          };
          return {
            createCacheUpdate: (e) => {
              const o = l();
              return (
                (t = !0),
                (n = n.then((e) =>
                  o.promise.then((t) => ({ ...e, ...t })).catch(() => e),
                )),
                {
                  update(t) {
                    const n = t.filter((e) => e.getScope()),
                      i = G(n, (e) => e.getScope().toLowerCase());
                    return (o.resolve(i), e ? r(i, e) : []);
                  },
                  cancel() {
                    o.reject();
                  },
                }
              );
            },
            getView: (e) => n.then((t) => r(t, e)),
            isInitialized: () => t,
          };
        })({ createProposition: k }),
        P = rs(window),
        D = {
          [jo]: qa,
          [_o]: Ja({
            modules: b,
            logger: t,
            storeInteractionMeta: u,
            storeClickMeta: h,
            autoCollectPropositionInteractions: a,
          }),
          [Fo]: Ga({
            modules: b,
            logger: t,
            storeInteractionMeta: u,
            autoCollectPropositionInteractions: a,
          }),
          [Ho]: Xa({ logger: t, executeRedirect: P, collect: s }),
          [zo]: ts({ modules: gs(s), logger: t }),
        },
        R = Wa({ schemaProcessors: D, logger: t }),
        T = (() => {
          let e = Promise.resolve([]);
          return {
            concat(t) {
              e = e.then((e) => t.then((t) => e.concat(t)).catch(() => e));
            },
            clear() {
              const t = e;
              return ((e = Promise.resolve([])), t);
            },
          };
        })(),
        O = ((e, t) => (n, r, o) => {
          if (!n) return () => {};
          if (!r) {
            const e = l();
            return (t.concat(e.promise), e.resolve);
          }
          return (t = [], n = []) => {
            (w(t) && e({ decisionsMeta: t, viewName: o }),
              w(n) &&
                e({
                  decisionsMeta: n,
                  eventType: Ko,
                  propositionAction: { reason: "Conflict" },
                  viewName: o,
                }));
          };
        })(s, T),
        N = (
          ({
            logger: e,
            prehidingStyle: t,
            showContainers: n,
            hideContainers: r,
            mergeQuery: o,
            processPropositions: i,
            createProposition: a,
            notificationHandler: s,
            consent: c,
          }) =>
          ({
            cacheUpdate: d,
            personalizationDetails: l,
            event: u,
            onResponse: p,
          }) => {
            const { state: g, wasSet: m } = c.current();
            (("out" === g && m) || (l.isRenderDecisions() ? r(t) : n()),
              o(u, l.createQueryDetails()));
            const f = s(
              l.isRenderDecisions(),
              l.isSendDisplayEvent(),
              l.getViewName(),
            );
            p(({ response: t }) => {
              const r = t.getPayloadsByType("personalization:decisions");
              w(r) ||
                e.logOnContentRendering({
                  status: "no-offers",
                  message: "No offers were returned.",
                  logLevel: "info",
                  detail: { query: l.createQueryDetails() },
                });
              const o = r.map((e) => a(e)),
                {
                  page: s = [],
                  view: c = [],
                  proposition: u = [],
                } = G(o, (e) => e.getScopeType()),
                p = d.update(c);
              let g, m, h;
              return (
                l.isRenderDecisions()
                  ? (({
                      render: g,
                      returnedPropositions: m,
                      returnedDecisions: h,
                    } = i([...s, ...p], u)),
                    w(s) &&
                      e.logOnContentRendering({
                        status: "rendering-started",
                        message:
                          "Started rendering propositions for page-wide scope.",
                        logLevel: "info",
                        detail: {
                          scope: Zt,
                          propositions: s.map((e) => e.toJSON()),
                        },
                      }),
                    w(p) &&
                      e.logOnContentRendering({
                        status: "rendering-started",
                        message:
                          "Rendering propositions started for view scope - " +
                          l.getViewName() +
                          ".",
                        logLevel: "info",
                        detail: {
                          scope: l.getViewName(),
                          propositions: p.map((e) => e.toJSON()),
                        },
                      }),
                    g().then(f),
                    n())
                  : ({ returnedPropositions: m, returnedDecisions: h } = i(
                      [],
                      [...s, ...p, ...u],
                    )),
                { propositions: m, decisions: h }
              );
            });
          }
        )({
          prehidingStyle: i,
          showContainers: c,
          hideContainers: d,
          mergeQuery: Da,
          processPropositions: R,
          createProposition: k,
          notificationHandler: O,
          consent: r,
          logger: t,
        }),
        M = (
          ({
            mergeDecisionsMeta: e,
            collectInteractions: t,
            collectClicks: n,
            getInteractionMetas: r,
            getClickMetas: o,
            getClickSelectors: i,
            autoCollectPropositionInteractions: a,
          }) =>
          ({ event: s, clickedElement: c }) => {
            const d = [];
            let l, u, p;
            if (
              ([t(c, r, a), n(c, i(), o)].forEach(
                ({
                  decisionsMeta: e,
                  propositionActionLabel: t,
                  propositionActionToken: n,
                  viewName: r,
                }) => {
                  (Array.prototype.push.apply(d, e),
                    !l && t && (l = t),
                    !u && n && (u = n),
                    !p && r && (p = r));
                },
              ),
              w(d))
            ) {
              const t = { eventType: Xo };
              (p && (t.web = { webPageDetails: { viewName: p } }),
                s.mergeXdm(t),
                e(
                  s,
                  d,
                  [$o.INTERACT],
                  ((e, t) => {
                    if (!t && !e) return;
                    const n = {};
                    return (e && (n.label = e), t && (n.tokens = [t]), n);
                  })(l, u),
                ));
            }
          }
        )({
          mergeDecisionsMeta: Pa,
          collectInteractions: fs,
          collectClicks: ka,
          getInteractionMetas: m,
          getClickMetas: v,
          getClickSelectors: y,
          autoCollectPropositionInteractions: a,
        }),
        A = (
          ({ processPropositions: e, viewCache: t, logger: n }) =>
          ({ personalizationDetails: r, onResponse: o }) => {
            let i, a;
            const s = r.getViewName();
            return (
              o(() => ({ propositions: i, decisions: a })),
              t.getView(s).then((t) => {
                let o;
                return r.isRenderDecisions()
                  ? (({
                      render: o,
                      returnedPropositions: i,
                      returnedDecisions: a,
                    } = e(t)),
                    n.logOnContentRendering({
                      status: "rendering-started",
                      message:
                        "Started rendering propositions for view scope - " +
                        s +
                        ".",
                      logLevel: "info",
                      detail: {
                        scope: s,
                        propositions: t.map((e) => e.toJSON()),
                      },
                    }),
                    o())
                  : (({ returnedPropositions: i, returnedDecisions: a } = e(
                      [],
                      t,
                    )),
                    []);
              })
            );
          }
        )({ processPropositions: R, viewCache: S, logger: t }),
        x = Na({
          processPropositions: R,
          createProposition: k,
          renderedPropositions: T,
          viewCache: S,
        }),
        L = (({ targetMigrationEnabled: e }) =>
          e
            ? (e) => {
                e.getPayload().mergeMeta({ target: { migration: !0 } });
              }
            : le)({ targetMigrationEnabled: o }),
        U = Ya({
          processPropositions: R,
          createProposition: k,
          notificationHandler: O,
        }),
        j = (
          ({ showContainers: e, consent: t }) =>
          () => {
            const { state: n, wasSet: r } = t.current();
            n === At && r ? e() : t.awaitConsent().catch(e);
          }
        )({ showContainers: c, consent: r });
      return oi({
        getPageLocation: I,
        logger: t,
        fetchDataHandler: N,
        viewChangeHandler: A,
        onClickHandler: M,
        isAuthoringModeEnabled: Sa,
        mergeQuery: Da,
        viewCache: S,
        showContainers: c,
        applyPropositions: x,
        setTargetMigration: L,
        mergeDecisionsMeta: Pa,
        renderedPropositions: T,
        onDecisionHandler: U,
        handleConsentFlicker: j,
      });
    };
  vs.namespace = "Personalization";
  const ws = _a.map((e) => vt(e));
  vs.configValidators = bt({
    prehidingStyle: Et().nonEmpty(),
    targetMigrationEnabled: ht().default(!1),
    autoCollectPropositionInteractions: bt({
      [hs]: gt(ws).default(La),
      [ys]: gt(ws).default(Ua),
    })
      .default({ [hs]: La, [ys]: Ua })
      .noUnknownFields(),
  });
  const Is = (e) =>
      null !== e &&
      "object" == typeof e &&
      Object.getPrototypeOf(e) === Object.prototype,
    bs = (e, t = {}, n = []) => (
      Object.keys(e).forEach((r) => {
        Is(e[r]) || Array.isArray(e[r])
          ? bs(e[r], t, [...n, r])
          : (t[[...n, r].join(".")] = e[r]);
      }),
      t
    );
  var Es = (e) => (Is(e) ? bs(e) : e);
  const Cs = "matcher",
    ks = "group",
    Ss = "historical",
    Ps = "eq",
    Ds = "ne",
    Rs = "ex",
    Ts = "nx",
    Os = "gt",
    Ns = "ge",
    Ms = "lt",
    As = "le",
    xs = "co",
    qs = "nc",
    Ls = "sw",
    Us = "ew",
    js = "and",
    _s = "or",
    Fs = "ordered",
    Bs = "mostRecent";
  function Vs(e) {
    return "object" == typeof e || void 0 === e;
  }
  function Hs(e) {
    return "number" == typeof e;
  }
  const zs = {
    [Ps]: {
      matches: (e, t, n = []) => {
        if (Vs(e[t])) return !1;
        const r = String(e[t]).toLowerCase();
        for (let e = 0; e < n.length; e += 1)
          if (!Vs(n[e]) && r === String(n[e]).toLowerCase()) return !0;
        return !1;
      },
    },
    [Ds]: {
      matches: (e, t, n = []) => {
        if (Vs(e[t])) return !1;
        const r = String(e[t]).toLowerCase();
        for (let e = 0; e < n.length; e += 1)
          if (!Vs(n[e]) && r === String(n[e]).toLowerCase()) return !1;
        return !0;
      },
    },
    [Rs]: { matches: (e, t) => void 0 !== e[t] && null !== e[t] },
    [Ts]: { matches: (e, t) => void 0 === e[t] || null === e[t] },
    [Os]: {
      matches: (e, t, n = []) => {
        const r = e[t];
        if (!Hs(r)) return !1;
        for (let e = 0; e < n.length; e += 1)
          if (Hs(n[e]) && r > n[e]) return !0;
        return !1;
      },
    },
    [Ns]: {
      matches: (e, t, n = []) => {
        const r = e[t];
        if (!Hs(r)) return !1;
        for (let e = 0; e < n.length; e += 1)
          if (Hs(n[e]) && r >= n[e]) return !0;
        return !1;
      },
    },
    [Ms]: {
      matches: (e, t, n = []) => {
        const r = e[t];
        if (!Hs(r)) return !1;
        for (let e = 0; e < n.length; e += 1)
          if (Hs(n[e]) && r < n[e]) return !0;
        return !1;
      },
    },
    [As]: {
      matches: (e, t, n = []) => {
        const r = e[t];
        if (!Hs(r)) return !1;
        for (let e = 0; e < n.length; e += 1)
          if (Hs(n[e]) && r <= n[e]) return !0;
        return !1;
      },
    },
    [xs]: {
      matches: (e, t, n = []) => {
        if (Vs(e[t])) return !1;
        const r = String(e[t]).toLowerCase();
        for (let e = 0; e < n.length; e += 1)
          if (!Vs(n[e]) && -1 !== r.indexOf(String(n[e]).toLowerCase()))
            return !0;
        return !1;
      },
    },
    [qs]: {
      matches: (e, t, n = []) => {
        if (Vs(e[t])) return !1;
        const r = String(e[t]).toLowerCase();
        for (let e = 0; e < n.length; e += 1)
          if (!Vs(n[e]) && -1 !== r.indexOf(String(n[e]).toLowerCase()))
            return !1;
        return !0;
      },
    },
    [Ls]: {
      matches: (e, t, n = []) => {
        if (Vs(e[t])) return !1;
        const r = String(e[t]).toLowerCase();
        for (let e = 0; e < n.length; e += 1)
          if (!Vs(n[e]) && r.startsWith(String(n[e]).toLowerCase())) return !0;
        return !1;
      },
    },
    [Us]: {
      matches: (e, t, n = []) => {
        if (Vs(e[t])) return !1;
        const r = String(e[t]).toLowerCase();
        for (let e = 0; e < n.length; e += 1)
          if (!Vs(n[e]) && r.endsWith(n[e].toLowerCase())) return !0;
        return !1;
      },
    },
  };
  function Js(e) {
    return void 0 === e;
  }
  const Gs = "eventId",
    Qs = "eventType",
    Xs = ["iam.eventType", Qs, "type"],
    Ws = ["iam.id", "id"],
    Ys = (e, t) => {
      for (let n = 0; n < t.length; n += 1) if (!Js(e[t[n]])) return t[n];
      throw new Error("The event does not match the expected schema.");
    },
    Ks = (e) => {
      const t = structuredClone(e);
      return (
        [
          [Ys(t, Xs), Qs],
          [Ys(t, Ws), Gs],
        ].forEach(([e, n]) => {
          e !== n && ((t[n] = t[e]), delete t[e]);
        }),
        t
      );
    };
  function $s(e, t) {
    return {
      evaluate: (e, n) => t.evaluate(e, n),
      toString: () => "Condition{type=" + e + ", definition=" + t + "}",
    };
  }
  function Zs(e, t, n) {
    return {
      evaluate: (r) => {
        const o = (function (e) {
          return zs[e];
        })(t);
        return !!o && o.matches(r, e, n);
      },
    };
  }
  function ec(e, t, n, r, o, i) {
    return {
      evaluate: (a, s) => {
        let c;
        return (
          (c =
            Bs === i
              ? (function (e, t, n, r = 0, o = 1 / 0) {
                  try {
                    return e.reduce(
                      (e, i, a) => {
                        const s = n.generateEventHash(Ks(i)),
                          c = t.events[s];
                        if (!c) return e;
                        const d = c.timestamps
                          .filter((e) => e >= r && e <= o)
                          .pop();
                        return d && d > e.timestamp
                          ? { index: a, timestamp: d }
                          : e;
                      },
                      { index: -1, timestamp: 0 },
                    ).index;
                  } catch {
                    return -1;
                  }
                })(e, a, s, r, o)
              : Fs === i
                ? (function (e, t, n, r = 0, o = 1 / 0) {
                    try {
                      let i = r;
                      const a = e.every((e) => {
                        const r = n.generateEventHash(Ks(e)),
                          a = t.events[r];
                        if (!a) return !1;
                        const s = a.timestamps[0],
                          c = s >= i && s <= o;
                        return ((i = s), c);
                      });
                      return Number(a);
                    } catch {
                      return 0;
                    }
                  })(e, a, s, r, o)
                : (function (e, t, n, r = 0, o = 1 / 0) {
                    return e.reduce((e, i) => {
                      try {
                        const a = n.generateEventHash(Ks(i)),
                          s = t.events[a];
                        if (!s) return e;
                        const { timestamps: c = [] } = s;
                        return e + c.filter((e) => e >= r && e <= o).length;
                      } catch {
                        return e;
                      }
                    }, 0);
                  })(e, a, s, r, o)),
          ((e, t, n) => {
            switch (t) {
              case Os:
                return e > n;
              case Ns:
                return e >= n;
              case Ms:
                return e < n;
              case As:
                return e <= n;
              case Ps:
                return e === n;
              case Ds:
                return e !== n;
              default:
                return !1;
            }
          })(c, t, n)
        );
      },
    };
  }
  function tc(e) {
    const { logic: t, conditions: n } = e;
    return (function (e, t) {
      return {
        evaluate: (n, r) =>
          js === e
            ? (function (e, t, n) {
                let r = !0;
                for (let o = 0; o < t.length; o += 1)
                  r = r && t[o].evaluate(e, n);
                return r;
              })(n, t, r)
            : _s === e &&
              (function (e, t, n) {
                let r = !1;
                for (let o = 0; o < t.length; o += 1)
                  if (((r = r || t[o].evaluate(e, n)), r)) return !0;
                return !1;
              })(n, t, r),
      };
    })(t, n.map(nc));
  }
  function nc(e) {
    const { type: t, definition: n } = e;
    if (Cs === t) {
      const e = (function (e) {
        const { key: t, matcher: n, values: r } = e;
        return Zs(t, n, r);
      })(n);
      return $s(t, e);
    }
    if (ks === t) {
      return $s(t, tc(n));
    }
    if (Ss === t) {
      const e = (function (e) {
        const {
          events: t,
          from: n,
          to: r,
          matcher: o,
          value: i,
          searchType: a,
        } = e;
        return ec(t, o, i, n, r, a);
      })(n);
      return $s(t, e);
    }
    throw new Error("Can not parse condition");
  }
  function rc(e) {
    const { id: t, type: n, detail: r } = e;
    return (function (e, t, n) {
      return { id: e, type: t, detail: n };
    })(t, n, r);
  }
  function oc(e) {
    const { condition: t, consequences: n, key: r } = e;
    return (function (e, t, n) {
      return {
        key: n,
        execute: (n, r) => (e.evaluate(n, r) ? t : []),
        toString: () => "Rule{condition=" + e + ", consequences=" + t + "}",
      };
    })(nc(t), n.map(rc), r);
  }
  function ic(e) {
    const { version: t, rules: n, metadata: r } = e,
      o = n.map(oc),
      i = (function (e) {
        if (!e) return;
        return {
          provider: e.provider,
          providerData: Object.assign({}, e.providerData),
        };
      })(r);
    return (function (e, t, n) {
      return { version: e, rules: t, metadata: n };
    })(t, o, i);
  }
  function ac(e, t, n) {
    const { providerData: r } = n,
      { identityTemplate: o } = r;
    return o.replace("<key>", t).replace("<identity>", e);
  }
  function sc(e, t = (e) => e[0]) {
    const n = {};
    return function (...r) {
      const o = t(r);
      return (Js(n[o]) && (n[o] = e(...r)), n[o]);
    };
  }
  function cc(e, t) {
    const n = 65535 & t;
    return ((((t - n) * e) | 0) + ((n * e) | 0)) | 0;
  }
  const dc = sc(
    function (e, t = 0) {
      let n;
      const r = e.length,
        o = 3432918353,
        i = 461845907;
      let a = t;
      const s = -2 & r;
      for (let t = 0; t < s; t += 2)
        ((n = e.charCodeAt(t) | (e.charCodeAt(t + 1) << 16)),
          (n = cc(n, o)),
          (n = ((131071 & n) << 15) | (n >>> 17)),
          (n = cc(n, i)),
          (a ^= n),
          (a = ((524287 & a) << 13) | (a >>> 19)),
          (a = (5 * a + 3864292196) | 0));
      return (
        r % 2 == 1 &&
          ((n = e.charCodeAt(s)),
          (n = cc(n, o)),
          (n = ((131071 & n) << 15) | (n >>> 17)),
          (n = cc(n, i)),
          (a ^= n)),
        (a ^= r << 1),
        (a ^= a >>> 16),
        (a = cc(a, 2246822507)),
        (a ^= a >>> 13),
        (a = cc(a, 3266489909)),
        (a ^= a >>> 16),
        a
      );
    },
    (e) => e.join("-"),
  );
  const lc = sc(function (e, t) {
    const n = dc(e),
      r = ((Math.abs(n) % t) / t) * 100;
    return Math.round(100 * r) / 100;
  });
  function uc(e, t, n) {
    return { allocation: lc(e, t), ...n };
  }
  function pc(e, t) {
    return t.map((t) => t.execute(e)).filter((e) => e.length > 0);
  }
  function gc(e, t) {
    !(function (e) {
      const { providerData: t } = e;
      if (!t) throw new Error("Provider data is missing in metadata");
      const { identityTemplate: n, buckets: r } = t;
      if (!n) throw new Error("Identity template is missing in provider data");
      if (!r) throw new Error("Buckets is missing in provider data");
    })(t);
    const n = e.filter((e) => !e.key),
      r = (function (e) {
        const t = {};
        for (let n = 0; n < e.length; n += 1) {
          const r = e[n];
          r.key && (t[r.key] || (t[r.key] = []), t[r.key].push(r));
        }
        return t;
      })(e),
      { buckets: o } = t.providerData;
    return {
      provider: "TGT",
      execute: (e) => {
        const i = (function (e) {
            const { xdm: t } = e;
            if (!t) throw new Error("XDM object is missing in the context");
            const { identityMap: n } = t;
            if (!n)
              throw new Error("Identity map is missing in the XDM object");
            const r = n.ECID;
            if (!r)
              throw new Error(
                "ECID identity namespace is missing in the identity map",
              );
            if (!Array.isArray(r) || 0 === r.length)
              throw new Error("ECID identities array is empty or not an array");
            const o = r[0].id;
            if (!o)
              throw new Error(
                "ECID identity is missing in the identities array",
              );
            return o;
          })(e),
          a = pc(e, n),
          s = Object.keys(r),
          c = [];
        for (let n = 0; n < s.length; n += 1) {
          const a = s[n],
            d = r[a],
            l = pc(uc(ac(i, a, t), o, e), d);
          c.push(...l);
        }
        return [...a, ...c];
      },
    };
  }
  function mc(
    e,
    t = {
      generateEventHash: () => {
        throw new Error("No hash function provided");
      },
    },
  ) {
    const { rules: n, metadata: r = {} } = ic(e);
    return (function (e, t, n) {
      const { provider: r } = t;
      return "TGT" === r
        ? gc(e, t)
        : (function (e, t) {
            return {
              provider: "DEFAULT",
              execute: (n) =>
                e.map((e) => e.execute(n, t)).filter((e) => e.length > 0),
            };
          })(e, n);
    })(n, r, t);
  }
  var fc = (e) => {
    const t = structuredClone(e),
      n = Object.keys(t)
        .sort()
        .reduce((e, n) => {
          const r = t[n];
          return null == r || "" === r ? e : (e += n + ":" + r);
        }, "");
    return F(n);
  };
  const hc = "events",
    yc = "~type",
    vc = "~source",
    wc = "com.adobe.eventType.edge",
    Ic = "com.adobe.eventType.rulesEngine",
    bc = "com.adobe.eventSource.requestContent",
    Ec = "cjmiam",
    Cc = "schema";
  var kc =
    (e = 30, t = 1e3) =>
    (n) => {
      let r = Object.entries(n).reduce(
        (e, [t, { timestamps: n = [] }]) => (
          n.forEach((n) => {
            e.push({ key: t, timestamp: n });
          }),
          e
        ),
        [],
      );
      const o = ((e) => {
        const t = new Date();
        return (t.setDate(t.getDate() - e), t);
      })(e);
      return (
        (r = r.filter(({ timestamp: e }) => e >= o)),
        r.sort((e, t) => e.timestamp - t.timestamp),
        (r = r.slice(-t)),
        r.reduce(
          (e, { key: t, timestamp: n }) => (
            e[t] || (e[t] = { timestamps: [] }),
            e[t].timestamps.push(n),
            e
          ),
          {},
        )
      );
    };
  const Sc = (e) => e?.scopeDetails?.activity?.id,
    Pc = () => {
      const e = {};
      return {
        getItem: (t) => (t in e ? e[t] : null),
        setItem: (t, n) => {
          e[t] = n;
        },
      };
    },
    Dc = (e) => {
      e.clear();
    };
  const Rc = {
    [Ec]: (e, t, n) => {
      const { html: r, mobileParameters: o } = n;
      return {
        schema: zo,
        data: {
          mobileParameters: o,
          webParameters: {},
          content: r,
          contentType: Ka,
        },
        id: e,
      };
    },
    [Cc]: (e, t, n) => {
      const { schema: r, data: o, id: i } = n;
      return { schema: r, data: o, id: i || e };
    },
  };
  const Tc = (e) => {
    const { schema: t, data: n } = e;
    if (t === Vo) return !0;
    if (t !== Bo) return !1;
    try {
      const e =
        "string" == typeof n.content ? JSON.parse(n.content) : n.content;
      return (
        e &&
        Object.prototype.hasOwnProperty.call(e, "version") &&
        Object.prototype.hasOwnProperty.call(e, "rules")
      );
    } catch {
      return !1;
    }
  };
  var Oc = (e, t) => {
      const n = (e) => {
          const { id: t, type: n, detail: r } = e;
          return "function" == typeof Rc[n] ? Rc[n](t, n, r) : r;
        },
        r = Sc(e),
        o = [],
        i = (e) => {
          const { data: t = {}, schema: n } = e,
            r = n === Vo ? t : t.content;
          r &&
            o.push(
              mc("string" == typeof r ? JSON.parse(r) : r, {
                generateEventHash: fc,
              }),
            );
        };
      return (
        Array.isArray(e.items) && e.items.filter(Tc).forEach(i),
        {
          rank: e?.scopeDetails?.rank || 1 / 0,
          evaluate: (i) => {
            const a = t.getEvent(Qo, r),
              s = a?.timestamps[0],
              c = ((e = []) => (Array.isArray(e) ? e.flat(1 / 0) : e))(
                o.map((e) => e.execute(i)),
              )
                .map(n)
                .map((e) => {
                  const n = t.addEvent({ eventType: $o.TRIGGER, eventId: r })
                    .timestamps[0];
                  return {
                    ...e,
                    data: { ...e.data, qualifiedDate: n, displayedDate: s },
                  };
                });
            return { ...e, items: c };
          },
          isEvaluable: o.length > 0,
        }
      );
    },
    Nc = ({ storage: e, logger: t }) => {
      let n,
        r,
        o,
        i = e;
      const a = (e) => {
        i = e;
        const t = ((e, t) => (n) => {
          try {
            const n = e.getItem(t);
            return [JSON.parse(n), n.length];
          } catch {}
          return [n, 0];
        })(i, hc);
        if (
          ((n = ((e, t) => (n) => {
            e.setItem(t, JSON.stringify(n));
          })(i, hc)),
          ([r, o] = t({})),
          o > 2097152)
        ) {
          const e = kc();
          ((r = e(r)), n(r));
        }
      };
      a(e);
      const s = (e = { eventType: null, eventId: null }, o = "insert") => {
        const { eventType: i, eventId: a } = e;
        if (!i || !a) return;
        const s = fc(e);
        if ("insertIfNotExists" === o && r[s]) return;
        (r[s] && Array.isArray(r[s].timestamps)) || (r[s] = { timestamps: [] });
        const c = new Date().getTime();
        return (
          r[s].timestamps.push(c),
          r[s].timestamps.sort(),
          t.info(
            "[Event History] Added event for",
            e,
            "with hash",
            s,
            "and timestamp",
            c,
          ),
          n(r),
          r[s]
        );
      };
      return {
        addExperienceEdgeEvent: (e) => {
          const { xdm: t } = e.getContent();
          if (
            !((e) => {
              const { _experience: t } = e || {};
              return !!t && "object" == typeof t;
            })(t)
          )
            return;
          const {
            _experience: {
              decisioning: {
                propositionEventType: n = {},
                propositionAction: { id: r } = {},
                propositions: o = [],
              } = {},
            },
          } = t;
          Object.keys(n)
            .filter((e) => 1 === n[e])
            .forEach((e) => {
              o.forEach((t) => {
                ((e) => e?.scopeDetails?.decisionProvider)(t) === hs &&
                  s({ eventId: Sc(t), eventType: e, action: r });
              });
            });
        },
        addEvent: s,
        addEventPayloads: (e = []) =>
          e.map(({ operation: e, event: t }) => s(t, e)),
        getEvent: (e, t) => {
          const n = fc({ eventType: e, eventId: t });
          if (r[n]) return r[n];
        },
        toJSON: () => r,
        setStorage: a,
      };
    };
  const Mc = (e, ...t) => t,
    Ac = (e, ...t) => !0;
  var xc = ({ collect: e }) => {
    let t = () => {};
    const n = new Set(),
      r = (e, t, r) => {
        const o = [e, t].join("-"),
          i =
            !r.has(o) &&
            (((e) => [$o.INTERACT, $o.DISMISS].includes(e))(e) || !n.has(o));
        return (r.add(o), n.add(o), i);
      },
      o = (t, n = []) => {
        if (!(n instanceof Array)) return Promise.resolve();
        if (!Object.values($o).includes(t)) return Promise.resolve();
        const o = [],
          i = new Set();
        return (
          n.forEach((e) => {
            const n = ((e) => {
              const { id: t, scope: n, scopeDetails: r } = e;
              return { id: t, scope: n, scopeDetails: r };
            })(e);
            r(t, n.id, i) && o.push(n);
          }),
          o.length > 0
            ? e({ decisionsMeta: o, eventType: ni(t), documentMayUnload: !0 })
            : Promise.resolve()
        );
      },
      i = (() => {
        let e = Mc,
          t = Ac,
          n = 0;
        const r = {};
        return {
          add: (e, t = void 0) => {
            return "function" != typeof e
              ? () => {}
              : ((n += 1),
                (r[n] = { callback: e, params: t }),
                {
                  id: n,
                  unsubscribe:
                    ((o = n),
                    () => {
                      delete r[o];
                    }),
                });
            var o;
          },
          emit: (...n) => {
            Object.values(r).forEach(({ callback: r, params: o }) => {
              const i = e(o, ...n);
              t(o, ...i) && r(...i);
            });
          },
          emitOne: (n, ...o) => {
            if (!n || !r[n]) return;
            const { callback: i, params: a } = r[n],
              s = e(a, ...o);
            t(a, ...s) && i(...s);
          },
          hasSubscriptions: () => Object.keys(r).length > 0,
          setEmissionPreprocessor: (t) => {
            "function" == typeof t && (e = t);
          },
          setEmissionCondition: (e) => {
            "function" == typeof e && (t = e);
          },
        };
      })();
    i.setEmissionPreprocessor((e, t) => {
      const { surfacesFilter: n, schemasFilter: r } = e;
      return [
        {
          propositions: t
            .filter((e) => !n || n.includes(e.scope))
            .map((e) => {
              const { items: t = [] } = e;
              return {
                ...e,
                items: t.filter((e) => !r || r.includes(e.schema)),
              };
            })
            .filter((e) => e.items.length > 0),
        },
        o,
      ];
    });
    return {
      refresh: (e) => {
        ((t = (t) => {
          t ? i.emitOne(t, e) : i.emit(e);
        }),
          t());
      },
      command: {
        optionsValidator: (e) =>
          (({ options: e }) =>
            bt({
              surfaces: ft(Et()).uniqueItems(),
              schemas: ft(Et()).uniqueItems(),
              callback: yt().required(),
            }).noUnknownFields()(e))({ options: e }),
        run: ({ surfaces: e, schemas: n, callback: r }) => {
          const { id: o, unsubscribe: a } = i.add(r, {
            surfacesFilter: e instanceof Array ? e : void 0,
            schemasFilter: n instanceof Array ? n : void 0,
          });
          return (t(o), Promise.resolve({ unsubscribe: a }));
        },
      },
    };
  };
  var qc = ({ contextProvider: e, decisionProvider: t }) => ({
    optionsValidator: (e) =>
      (({ options: e }) =>
        bt({
          renderDecisions: ht(),
          personalization: bt({ decisionContext: bt({}) }),
        }).noUnknownFields()(e))({ options: e }),
    run: ({ renderDecisions: n, decisionContext: r, applyResponse: o }) =>
      o({ renderDecisions: n, propositions: t.evaluate(e.getContext(r)) }),
  });
  const Lc = ({
    config: e,
    eventManager: t,
    createNamespacedStorage: n,
    consent: r,
    getBrowser: o,
    logger: i,
  }) => {
    const { orgId: a, personalizationStorageEnabled: s } = e,
      c = wa({ eventManager: t, mergeDecisionsMeta: Pa }),
      d = n(z(a) + ".decisioning.");
    s || Dc(d.persistent);
    const l = Nc({ storage: Pc(), logger: i }),
      u = (({ eventRegistry: e }) => {
        const t = {},
          n = (n) => {
            const r = Sc(n);
            if (!r) return;
            const o = Oc(n, e);
            o.isEvaluable && (t[r] = o);
          };
        return {
          addPayload: n,
          addPayloads: (e) => {
            e.forEach(n);
          },
          evaluate: (e = {}) =>
            Object.values(t)
              .sort(({ rank: e }, { rank: t }) => e - t)
              .map((t) => t.evaluate(e))
              .filter((e) => e.items.length > 0),
        };
      })({ eventRegistry: l }),
      p = (({ eventRegistry: e, window: t, getBrowser: n }) => {
        const r = new Date().getTime(),
          o = () => {
            const e = new Date(),
              t = e.getTime();
            return {
              pageLoadTimestamp: r,
              currentTimestamp: t,
              currentDate: e.getDate(),
              "~state.com.adobe.module.lifecycle/lifecyclecontextdata.dayofweek":
                e.getDay() + 1,
              "~state.com.adobe.module.lifecycle/lifecyclecontextdata.hourofday":
                e.getHours(),
              currentMinute: e.getMinutes(),
              currentMonth: e.getMonth(),
              currentYear: e.getFullYear(),
              pageVisitDuration: t - r,
              "~timestampu": t / 1e3,
              "~timestampz": e.toISOString(),
            };
          },
          i = {
            browser: { name: n() },
            page: { title: t.title, url: t.url, ...pe(t.url) },
            referringPage: { url: t.referrer, ...pe(t.referrer) },
          };
        return {
          getContext: (n = {}) => {
            const r = {
              ...{
                ...i,
                ...o(),
                window: {
                  height: t.height,
                  width: t.width,
                  scrollY: t.scrollY,
                  scrollX: t.scrollX,
                },
                "~sdkver": In,
              },
              ...n,
            };
            return { ...Es(r), events: e.toJSON() };
          },
        };
      })({ eventRegistry: l, window: window, getBrowser: o }),
      g = qc({ contextProvider: p, decisionProvider: u }),
      m = xc({ collect: c });
    let f;
    return {
      lifecycle: {
        onDecision({ propositions: e }) {
          m.refresh(e);
        },
        onComponentsRegistered(e) {
          ((f = (
            ({ lifecycle: e, eventRegistry: t }) =>
            ({
              renderDecisions: n = !1,
              propositions: r = [],
              event: o,
              personalization: i,
            }) => {
              if (e) {
                const a = ((e) => {
                  const t = [];
                  return (
                    e.forEach((e) => {
                      const n = [];
                      (e.items.forEach((e) => {
                        "https://ns.adobe.com/personalization/eventHistoryOperation" ===
                        e.schema
                          ? t.push({
                              operation: e.data.operation,
                              event: {
                                eventId: e.data.content["iam.id"],
                                eventType: e.data.content["iam.eventType"],
                              },
                            })
                          : n.push(e);
                      }),
                        (e.items = n));
                    }),
                    t
                  );
                })(r);
                (t.addEventPayloads(a),
                  e.onDecision({
                    renderDecisions: n,
                    propositions: r,
                    event: o,
                    personalization: i,
                  }));
              }
              return { propositions: r };
            }
          )({ lifecycle: e.lifecycle, eventRegistry: l })),
            s &&
              r
                .awaitConsent()
                .then(() => {
                  l.setStorage(d.persistent);
                })
                .catch(() => {
                  d && Dc(d.persistent);
                }));
        },
        onBeforeEvent({
          event: e,
          renderDecisions: t,
          personalization: n = {},
          onResponse: r = le,
        }) {
          const { decisionContext: o = {} } = n;
          r(
            (({
              renderDecisions: e,
              decisionProvider: t,
              applyResponse: n,
              event: r,
              personalization: o,
              decisionContext: i,
            }) => {
              const a = { ...Es(r.getContent()), ...i };
              return ({ response: i }) => {
                if (
                  (t.addPayloads(
                    i.getPayloadsByType("personalization:decisions"),
                  ),
                  !r.hasQuery())
                )
                  return { propositions: [] };
                const s = t.evaluate(a);
                return n({
                  renderDecisions: e,
                  propositions: s,
                  event: r,
                  personalization: o,
                });
              };
            })({
              renderDecisions: t,
              decisionProvider: u,
              applyResponse: f,
              event: e,
              personalization: n,
              decisionContext: p.getContext({ [yc]: wc, [vc]: bc, ...o }),
            }),
          );
        },
        onBeforeRequest({ request: e }) {
          const t = e.getPayload().toJSON(),
            { events: n = [] } = t;
          0 !== n.length && n.forEach((e) => l.addExperienceEdgeEvent(e));
        },
      },
      commands: {
        evaluateRulesets: {
          run: ({ renderDecisions: e, personalization: t = {} }) => {
            const { decisionContext: n = {} } = t;
            return g.run({
              renderDecisions: e,
              decisionContext: { [yc]: Ic, [vc]: bc, ...n },
              applyResponse: f,
            });
          },
          optionsValidator: g.optionsValidator,
        },
        subscribeRulesetItems: m.command,
      },
    };
  };
  ((Lc.namespace = "RulesEngine"),
    (Lc.configValidators = bt({
      personalizationStorageEnabled: ht().default(!1),
    })));
  var Uc = bt({
      streamingMedia: bt({
        channel: Et().nonEmpty().required(),
        playerName: Et().nonEmpty().required(),
        appVersion: Et(),
        mainPingInterval: wt().minimum(10).maximum(50).default(10),
        adPingInterval: wt().minimum(1).maximum(10).default(10),
      }).noUnknownFields(),
    }),
    jc = ({
      config: e,
      trackMediaEvent: t,
      trackMediaSession: n,
      mediaResponseHandler: r,
    }) => ({
      lifecycle: {
        onBeforeEvent({ mediaOptions: e, onResponse: t = le }) {
          if (!e) return;
          const { legacy: n, playerId: o, getPlayerDetails: i } = e;
          n ||
            t(({ response: e }) =>
              r({ playerId: o, getPlayerDetails: i, response: e }),
            );
        },
      },
      commands: {
        createMediaSession: {
          optionsValidator: (e) =>
            (({ options: e }) =>
              gt(
                [
                  bt({
                    playerId: Et().required(),
                    getPlayerDetails: yt().required(),
                    xdm: bt({
                      mediaCollection: bt({
                        sessionDetails: bt(mt()).required(),
                      }),
                    }),
                    edgeConfigOverrides: St,
                  }).required(),
                  bt({
                    xdm: bt({
                      mediaCollection: bt({
                        playhead: wt().required(),
                        sessionDetails: bt(mt()).required(),
                      }),
                    }),
                    edgeConfigOverrides: St,
                  }).required(),
                ],
                "an object with playerId, getPlayerDetails and xdm.mediaCollection.sessionDetails, or an object with xdm.mediaCollection.playhead and xdm.mediaCollection.sessionDetails",
              )(e))({ options: e }),
          run: n,
        },
        sendMediaEvent: {
          optionsValidator: (e) =>
            (({ options: e }) =>
              gt(
                [
                  bt({
                    playerId: Et().required(),
                    xdm: bt({
                      eventType: Ct(...Object.values(Yr)).required(),
                      mediaCollection: bt(mt()),
                    }).required(),
                  }).required(),
                  bt({
                    xdm: bt({
                      eventType: Ct(...Object.values(Yr)).required(),
                      mediaCollection: bt({
                        playhead: wt().integer().required(),
                        sessionID: Et().required(),
                      }).required(),
                    }).required(),
                  }).required(),
                ],
                "Error validating the sendMediaEvent command options.",
              )(e))({ options: e }),
          run: (n) =>
            e.streamingMedia
              ? t(n)
              : Promise.reject(new Error("Streaming media is not configured.")),
        },
      },
    });
  const _c = ({
    config: e,
    logger: t,
    eventManager: n,
    sendEdgeNetworkRequest: r,
    consent: o,
  }) => {
    const i = eo(),
      a = Kr({
        config: e,
        eventManager: n,
        consent: o,
        sendEdgeNetworkRequest: r,
        setTimestamp: wn(() => new Date()),
      }),
      s = to({ mediaSessionCacheManager: i, mediaEventManager: a, config: e }),
      c = no({ config: e, mediaEventManager: a, mediaSessionCacheManager: i }),
      d = oo({ mediaSessionCacheManager: i, config: e, trackMediaEvent: s });
    return jc({
      config: e,
      trackMediaEvent: s,
      mediaResponseHandler: d,
      trackMediaSession: c,
    });
  };
  ((_c.namespace = "Streaming media"), (_c.configValidators = Uc));
  const Fc = "advertising",
    Bc = "_les_lsc",
    Vc = "lastConversionTime",
    Hc = "surferId",
    zc = "rampId",
    Jc = "id5Id",
    Gc = "trackingCode",
    Qc = "trackingIdentities",
    Xc = "Ad conversion submission failed",
    Wc = "ev_lcc";
  let Yc = "",
    Kc = "",
    $c = null;
  const Zc = () =>
      $c ||
      (($c = new Promise((e, t) => {
        setTimeout(() => {
          const n =
              "https:" === document.location.protocol ? "https:" : "http:",
            r = g(
              "iframe",
              {
                src:
                  n +
                  "//pixel.everesttech.net/1/gr?ev_gb=0&url=" +
                  n +
                  "%2F%2Fwww.everestjs.net%2Fstatic%2Fpixel_details.html%23google%3D__EFGCK__%26gsurfer%3D__EFGSURFER__%26imsId%3D__EFIMSORGID__%26is_fb_cookie_synced%3D__EFFB__%26optout%3D__EFOPTOUT__%26throttleCookie%3D__EFSYNC__%26time%3D__EFTIME__%26ev_lcc%3D__LCC__",
              },
              {
                height: 0,
                width: 0,
                frameBorder: 0,
                style: { display: "none" },
              },
              [],
            );
          var o;
          ((o = r),
            document.body
              ? document.body.appendChild(o)
              : window.addEventListener(
                  "load",
                  () => {
                    document.body.appendChild(o);
                  },
                  !1,
                ));
          var i;
          ((i = function n(r) {
            var o;
            if (r.origin.includes("www.everestjs.net"))
              try {
                const t = r.data,
                  i = t.substring(t.indexOf("#") + 1).split("&");
                let a, s;
                for (const e of i) {
                  const t = e.split("=");
                  "gsurfer" === t[0] && t[1]
                    ? (a = t[1])
                    : t[0] === Wc && t[1] && "__LCC__" !== t[1] && (s = t[1]);
                }
                ((o = n),
                  window.removeEventListener("message", o, !1),
                  a
                    ? ((Yc = a),
                      (Kc = s),
                      e({ surferId: Yc, displayClickCookie: Kc }))
                    : e({ surferId: null, displayClickCookie: null }));
              } catch (e) {
                t(e);
              } finally {
                $c = null;
              }
          }),
            window.addEventListener("message", i, !1));
        }, 5e3);
      })),
      $c),
    ed = function (e, t = !0) {
      if (Yc && "" !== Yc) return Promise.resolve(Yc);
      if (e) {
        const t = e.getValue(Hc);
        if (t) return ((Yc = t), Promise.resolve(t));
      }
      return t
        ? Zc().then(
            (t) => (
              e &&
                t &&
                (t.surferId && e.setValue(Hc, t.surferId),
                t.displayClickCookie && e.setValue(Wc, t.displayClickCookie)),
              t.surferId
            ),
          )
        : Promise.resolve(null);
    },
    td = 15,
    nd = 3e4,
    rd = 500,
    od = 5e3,
    id = {
      rampIdEnv: void 0,
      rampIdCallInitiated: !1,
      inProgressRampIdPromise: null,
      envelopeRetrievalInProgress: !1,
    },
    ad = (e, t, n, r) => {
      let o;
      try {
        o = JSON.parse(e).envelope;
      } catch {
        o = e;
      }
      o && !id.rampIdCallInitiated
        ? ((id.rampIdCallInitiated = !0),
          (id.rampIdEnv = o),
          (id.envelopeRetrievalInProgress = !1),
          (id.inProgressRampIdPromise = null),
          n.setValue(zc, id.rampIdEnv),
          t(id.rampIdEnv))
        : (r.warn("Invalid RampID envelope received", { envelope: o }),
          (id.envelopeRetrievalInProgress = !1));
    },
    sd = (e, t, n) => (
      id.inProgressRampIdPromise ||
        (id.inProgressRampIdPromise = new Promise((r, o) => {
          x(e, {
            onLoad: () => {
              (void 0 === window.ats ||
                id.envelopeRetrievalInProgress ||
                ((id.envelopeRetrievalInProgress = !0),
                window.ats
                  .retrieveEnvelope()
                  .then((e) => {
                    e
                      ? ad(e, r, t, n)
                      : ((id.envelopeRetrievalInProgress = !1),
                        window.addEventListener("lrEnvelopePresent", () => {
                          id.envelopeRetrievalInProgress ||
                            ((id.envelopeRetrievalInProgress = !0),
                            window.ats.retrieveEnvelope().then(
                              (e) => ad(e, r, t, n),
                              (e) => {
                                (n.error(
                                  "Failed to retrieve envelope after event",
                                  e,
                                ),
                                  (id.envelopeRetrievalInProgress = !1),
                                  o(e),
                                  (id.inProgressRampIdPromise = null));
                              },
                            ));
                        }));
                  })
                  .catch((e) => {
                    (n.error("Error retrieving envelope", e),
                      (id.envelopeRetrievalInProgress = !1),
                      o(e),
                      (id.inProgressRampIdPromise = null));
                  })),
                ((e, t, n, r) => {
                  let o = td,
                    i = 1,
                    a = 0;
                  const s = () => {
                    if (id.rampIdEnv) return;
                    if (a > nd)
                      return (
                        r.error("Maximum retry time exceeded"),
                        (id.envelopeRetrievalInProgress = !1),
                        t(new Error("Failed to retrieve RampID - timeout")),
                        void (id.inProgressRampIdPromise = null)
                      );
                    if (0 === o)
                      return (
                        r.error("Maximum retries exceeded"),
                        (id.envelopeRetrievalInProgress = !1),
                        t(
                          new Error(
                            "Failed to retrieve RampID after maximum retries",
                          ),
                        ),
                        void (id.inProgressRampIdPromise = null)
                      );
                    const c = Math.min(rd * i, od);
                    setTimeout(() => {
                      ((a += c),
                        (o -= 1),
                        (i += 1),
                        void 0 === window.ats ||
                        null === window.ats ||
                        id.rampIdEnv ||
                        id.envelopeRetrievalInProgress
                          ? s()
                          : ((id.envelopeRetrievalInProgress = !0),
                            window.ats.retrieveEnvelope().then(
                              (t) => {
                                (ad(t, e, n, r), id.rampIdEnv || s());
                              },
                              () => {
                                (r.warn("Failed to retrieve envelope"),
                                  (id.envelopeRetrievalInProgress = !1),
                                  s());
                              },
                            )));
                    }, c);
                  };
                  s();
                })(r, o, t, n));
            },
            onError: (e) => {
              (n.error("Could not initiate RampID call.", e),
                (id.inProgressRampIdPromise = null),
                o(e));
            },
          });
        })),
      id.inProgressRampIdPromise
    ),
    cd = (e, t, n, r = !0) => {
      if (id.rampIdEnv) return Promise.resolve(id.rampIdEnv);
      if (n) {
        const e = n.getValue(zc);
        if (e) return ((id.rampIdEnv = e), Promise.resolve(e));
      }
      return r ? sd(t, n, e) : Promise.resolve(null);
    };
  let dd = "",
    ld = null;
  const ud = function (e, t, n = !0) {
      return dd && "" !== dd
        ? Promise.resolve(dd)
        : n
          ? ((e, t) => (
              (e = Math.floor(Number(e))),
              ld ||
                ((ld = new Promise((n, r) => {
                  if (!e)
                    return (
                      t.error("Missing partner ID"),
                      (ld = null),
                      void r(new Error("ID5 partner ID is required"))
                    );
                  const o = () => {
                    try {
                      if (void 0 === window.ID5)
                        return void r(
                          new Error(
                            "ID5 object not available after script load",
                          ),
                        );
                      const o = window.ID5.init({ partnerId: e });
                      ((dd = o.getUserId()),
                        void 0 === dd || "" === dd
                          ? window.ID5.init({ partnerId: e }).onAvailable(
                              function (r) {
                                ((dd = r.getUserId()),
                                  dd
                                    ? (n(dd), (ld = null))
                                    : window.ID5.init({
                                        partnerId: e,
                                      }).onAvailable(function (e) {
                                        ((dd = e.getUserId()),
                                          void 0 !== dd && "" !== dd
                                            ? n(dd)
                                            : t.error(
                                                "Failed to get ID5 ID after all retries",
                                              ),
                                          (ld = null));
                                      }));
                              },
                              1e3,
                            )
                          : (n(dd), (ld = null)));
                    } catch (e) {
                      (t.error("Error during ID5 initialization", e),
                        r(e),
                        (ld = null));
                    }
                  };
                  void 0 !== window.ID5
                    ? o()
                    : x("https://www.everestjs.net/static/id5-api.js", {
                        onLoad: o,
                        onError: (e) => {
                          (t.error("Script loading failed", e),
                            (ld = null),
                            r(e));
                        },
                      });
                })),
                ld)
            ))(t, e)
              .then((e) => e)
              .catch((t) => {
                throw (e.error("Failed to get ID5 ID", t), t);
              })
          : Promise.resolve(null);
    },
    pd = (e) =>
      e && Array.isArray(e)
        ? e
            .filter((e) => e && !0 === e.enabled && e.advertiserId)
            .map((e) => e.advertiserId)
            .join(", ")
        : "",
    gd = (e, t, n, r, o = !1) => {
      const i = n.getValue(Bc),
        a = n.getValue(Wc),
        s = {
          advertising: {
            ...(i && i.click_time && { lastSearchClick: i.click_time }),
            ...(a && { lastDisplayClick: a }),
            stitchIds: {
              ...(e[Hc] && { surferId: e[Hc] }),
              ...(e[Jc] && { id5: e[Jc] }),
              ...(e[zc] && { rampIdEnv: e[zc] }),
              ipAddress: "DUMMY_IP_ADDRESS",
            },
            advIds: pd(r.advertiserSettings),
            ...(o && { eventType: "advertising.enrichment" }),
          },
        };
      return (t.mergeQuery(s), t);
    },
    md = (e, t) => {
      const n = Date.now(),
        r = t.getValue(e + "_last_conversion");
      return Boolean(r && n - r < 18e5);
    };
  async function fd({
    eventManager: e,
    cookieManager: t,
    logger: n,
    componentConfig: r,
    adConversionHandler: o,
  }) {
    const i = {},
      a = {},
      s = [],
      c = async () => {
        if (((s = i), (c = a), !Object.entries(s).some(([e]) => !c[e])))
          return null;
        var s, c;
        const d = Object.keys(i);
        try {
          const s = gd(i, e.createEvent(), t, r, !0),
            c = await o.trackAdConversion({ event: s });
          return (
            ((e, t, n, r) => {
              const o = Date.now();
              (e.forEach((e) => {
                ((t[e] = !0),
                  n.setValue(e + "_last_conversion", o),
                  r.info(
                    "Ad conversion submitted successfully".replace("{0}", e),
                  ));
              }),
                n.setValue(Vc, o));
            })(d, a, t, n),
            c
          );
        } catch (e) {
          return (n.error(Xc, e), null);
        }
      },
      d = ((e, t, n) => {
        const r = {};
        return (
          md(Hc, n) || (r.surferId = ed(n, !0).catch(() => null)),
          t.id5PartnerId &&
            !md(Jc, n) &&
            (r.id5Id = ud(e, t.id5PartnerId).catch(() => null)),
          t.rampIdJSPath &&
            !md(zc, n) &&
            (r.rampId = cd(e, t.rampIdJSPath, n, !0).catch(() => null)),
          r
        );
      })(n, r, t);
    if (0 === Object.keys(d).length) return [];
    const l = Object.entries(d).map(([e, t]) =>
      t
        .then((t) => {
          if (t) {
            i[e] = t;
            const n = c();
            n && s.push(n);
          }
        })
        .catch(
          (t) => (
            n.error("Unable to obtain ad identity".replace("{0}", e), t),
            null
          ),
        ),
    );
    return (await Promise.all(l), Promise.all(s));
  }
  var hd = ({
    eventManager: e,
    cookieManager: t,
    adConversionHandler: n,
    logger: r,
    componentConfig: o,
  }) => {
    const i = o?.advertiserSettings ? pd(o.advertiserSettings) : "";
    return async (a = {}) => {
      const { skwcid: s, efid: c } = (() => {
          const e = ye.parse(window.location.search);
          return { skwcid: e.s_kwcid, efid: e.ef_id };
        })(),
        d = !(!s && !c);
      try {
        return d
          ? await (async function ({
              eventManager: e,
              cookieManager: t,
              adConversionHandler: n,
              logger: r,
              skwcid: o,
              efid: i,
            }) {
              r.info("Processing ad conversion", { skwcid: o, efid: i });
              const a = e.createEvent();
              if (void 0 !== o || void 0 !== i) {
                const e = {
                  click_time: Date.now(),
                  ...(void 0 !== o && { skwcid: o }),
                  ...(void 0 !== i && { efid: i }),
                };
                t.setValue(Bc, e);
              }
              const s = {
                _experience: {
                  adcloud: {
                    conversionDetails: {
                      ...(void 0 !== o && { [Gc]: o }),
                      ...(void 0 !== i && { [Qc]: i }),
                    },
                  },
                },
                eventType: "advertising.enrichment_ct",
              };
              (a.setUserXdm(s), t.setValue(Vc, Date.now()));
              try {
                return await n.trackAdConversion({ event: a });
              } catch (e) {
                throw (r.error(Xc, e), e);
              }
            })({
              eventManager: e,
              cookieManager: t,
              adConversionHandler: n,
              logger: r,
              skwcid: s,
              efid: c,
              optionsFromCommand: a,
            })
          : i
            ? await fd({
                eventManager: e,
                cookieManager: t,
                logger: r,
                componentConfig: o,
                adConversionHandler: n,
              })
            : null;
      } catch (e) {
        r.error("Error in sendAdConversion:", e);
      }
    };
  };
  var yd = ({
      logger: e,
      config: t,
      eventManager: n,
      cookieManager: r,
      adConversionHandler: o,
    }) => {
      const i = t.advertising,
        a = { surferIdAppendedToAepEvent: !1 },
        s = hd({
          eventManager: n,
          cookieManager: r,
          adConversionHandler: o,
          logger: e,
          componentConfig: i,
        });
      return {
        lifecycle: {
          onComponentsRegistered() {
            s();
          },
          onBeforeEvent: ({ event: t, options: n = {} }) => {
            !(async function ({
              cookieManager: e,
              logger: t,
              state: n,
              event: r,
              componentConfig: o,
              options: i,
            }) {
              if (
                !n.surferIdAppendedToAepEvent &&
                !((e) =>
                  "disabled" === e.handleAdvertisingData ||
                  null === e.handleAdvertisingData)(i) &&
                !n.processingAdvertisingIds
              ) {
                n.processingAdvertisingIds = !0;
                try {
                  const a = await ed(
                      e,
                      ((e) => "wait" === e.handleAdvertisingData)(i),
                    ),
                    s = await ud(t, null, !1),
                    c = await cd(t, null, e, !1),
                    d = {
                      ...(a && { surferId: a }),
                      ...(s && { id5Id: s }),
                      ...(c && { rampId: c }),
                    };
                  (gd(d, r, e, o),
                    Object.keys(d).length > 0 &&
                      (n.surferIdAppendedToAepEvent = !0));
                } catch (e) {
                  t.error("Error in onBeforeSendEvent hook:", e);
                } finally {
                  n.processingAdvertisingIds = !1;
                }
              }
            })({
              cookieManager: r,
              logger: e,
              state: a,
              event: t,
              componentConfig: i,
              options: n,
            });
          },
        },
      };
    },
    vd = bt({
      advertising: bt({
        id5PartnerId: Et(),
        rampIdJSPath: Et(),
        advertiserSettings: ft(
          bt({
            advertiserId: Et().required(),
            enabled: ht().required(),
          }).noUnknownFields(),
        ),
      }).noUnknownFields(),
    }),
    wd = ({ orgId: e, logger: t }) => {
      const n = d({ logger: t, cookieJar: o }),
        r = (t, n = !0) => (n ? J(e, t) : t),
        i = (e = 30) => new Date(Date.now() + 60 * e * 1e3),
        a = (e, o = !0) => {
          try {
            const t = r(e, o),
              i = n.get(t);
            return i
              ? ((e) => {
                  try {
                    if (e?.startsWith("%7B") || e?.startsWith("{"))
                      return JSON.parse(decodeURIComponent(e));
                  } catch {}
                  return e;
                })(i)
              : null;
          } catch (n) {
            return (t.error("Error reading cookie: " + e, n), null);
          }
        },
        s = (e, o, i = {}, a = !0) => {
          try {
            const t = r(e, a),
              s = ((e) =>
                "object" == typeof e && null !== e
                  ? encodeURIComponent(JSON.stringify(e))
                  : e)(o);
            return (n.set(t, s, i), !0);
          } catch (n) {
            return (t.error("Error writing cookie: " + e, n), !1);
          }
        };
      return {
        setValue: (e, t, n = {}) => {
          const r = { ...(a(Fc) || {}), [e]: t };
          return s(Fc, r, { expires: i(1440), ...n });
        },
        getValue: (e) => (a(Fc) || {})[e],
      };
    };
  const Id = ({
    logger: e,
    config: t,
    eventManager: n,
    sendEdgeNetworkRequest: r,
    consent: o,
  }) => {
    const i = wd({ orgId: t.orgId, logger: e }),
      a = (({
        sendEdgeNetworkRequest: e,
        consent: t,
        createDataCollectionRequest: n,
        createDataCollectionRequestPayload: r,
        logger: o,
      }) => ({
        trackAdConversion: ({ event: i }) => {
          const a = r();
          (a.addEvent(i), i.finalize());
          const s = n({ payload: a });
          return t.awaitConsent().then(() =>
            e({ request: s })
              .then(() => ({ success: !0 }))
              .catch((e) => {
                throw (o.error("Failed to send ad conversion event", e), e);
              }),
          );
        },
      }))({
        sendEdgeNetworkRequest: r,
        consent: o,
        createDataCollectionRequest: nn,
        createDataCollectionRequestPayload: an,
        logger: e,
      });
    return yd({
      logger: e,
      config: t,
      eventManager: n,
      cookieManager: i,
      adConversionHandler: a,
    });
  };
  ((Id.namespace = "Advertising"),
    (Id.configValidators = vd),
    (({ components: e }) => {
      const t = window.__alloyNS;
      t &&
        t.forEach((t) => {
          const n = Dt({
              console: nr,
              locationSearch: window.location.search,
              createLogger: $t,
              instanceName: t,
              createNamespacedStorage: tr,
              getMonitors: vn,
            }),
            r = (
              (e) =>
              ([t, n, [r, o]]) => {
                e(r, o).then(t, n);
              }
            )(ur({ instanceName: t, logController: n, components: e })),
            o = window[t].q;
          ((o.push = r),
            n.logger.logOnInstanceCreated({ instance: r }),
            o.forEach(r));
        });
    })({ components: [Lr, _r, Qr, Wr, So, vs, Lc, _c, Id] }));
})();
